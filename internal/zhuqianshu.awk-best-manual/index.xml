<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>最好的awk手册 | JiangLab</title>
    <link>https://wukong.tongji.edu.cn/internal/zhuqianshu.awk-best-manual/</link>
      <atom:link href="https://wukong.tongji.edu.cn/internal/zhuqianshu.awk-best-manual/index.xml" rel="self" type="application/rss+xml" />
    <description>最好的awk手册</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>zh-Hans</language><lastBuildDate>Mon, 21 Dec 2020 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://wukong.tongji.edu.cn/images/logo_hu9e034b45a7d5e2bc1af5b58f309a8548_109997_300x300_fit_lanczos_3.png</url>
      <title>最好的awk手册</title>
      <link>https://wukong.tongji.edu.cn/internal/zhuqianshu.awk-best-manual/</link>
    </image>
    
    <item>
      <title>1. 前言</title>
      <link>https://wukong.tongji.edu.cn/internal/zhuqianshu.awk-best-manual/1/</link>
      <pubDate>Mon, 21 Dec 2020 00:00:00 +0000</pubDate>
      <guid>https://wukong.tongji.edu.cn/internal/zhuqianshu.awk-best-manual/1/</guid>
      <description>&lt;h3 id=&#34;有关本手册-&#34;&gt;有关本手册 :&lt;/h3&gt;
&lt;p&gt;这是一本awk学习指引, 其重点着重于 :&lt;br&gt;
        awk 适于解决哪些问题 ?&lt;br&gt;
        awk 常见的解题模式为何 ?&lt;br&gt;
为使读者快速掌握awk解题的模式及特性, 本手册系由一些较具代表性的范例及其题解所构成; 各范例由浅入深, 彼此间相互连贯,范例中并对所使用的awk语法及指令辅以必要的说明. 有关awk的指令, 函数,&amp;hellip;等条列式的说明则收录于附录中, 以利读者往后撰写程序时查阅. 如此编排, 可让读者在短时间内顺畅地学会使用awk来解决问题. 建议读者循着范例上机实习, 以加深学习效果.&lt;/p&gt;
&lt;h3 id=&#34;读者宜先具备下列背景-&#34;&gt;读者宜先具备下列背景 :&lt;/h3&gt;
&lt;p&gt;[a.] UNIX 环境下的简单操作及基本概念.&lt;br&gt;
例如 : 文件编辑, 文件复制 及 管道, 输入/输出重定向 等概念&lt;br&gt;
[b.] C 语言的基本语法及流程控制指令.&lt;br&gt;
(awk 指令并不多, 且其中之大部分与 C语言中之用法一致, 本手册中对该类指令之语法及特性不再加以繁冗的说明, 读者若欲深究,可自行翻阅相关的 C 语言书籍)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2. awk概述  </title>
      <link>https://wukong.tongji.edu.cn/internal/zhuqianshu.awk-best-manual/2/</link>
      <pubDate>Mon, 21 Dec 2020 00:00:00 +0000</pubDate>
      <guid>https://wukong.tongji.edu.cn/internal/zhuqianshu.awk-best-manual/2/</guid>
      <description>&lt;h3 id=&#34;为什么使用awk&#34;&gt;为什么使用awk&lt;/h3&gt;
&lt;p&gt;awk 是一种程序语言. 它具有一般程序语言常见的功能.&lt;br&gt;
因awk语言具有某些特点, 如 : 使用直译器(Interpreter)不需先行编译; 变量无类型之分(Typeless), 可使用文字当数组的下标(Associative Array)&amp;hellip;等特色. 因此, 使用awk撰写程序比起使用其它语言更简洁便利且节省时间. awk还具有一些内建功能, 使得awk擅于处理具数据行(Record), 字段(Field)型态的资料; 此外, awk内建有pipe的功能, 可将处理中的数据传送给外部的 Shell命令加以处理, 再将Shell命令处理后的数据传回awk程序, 这个特点也使得awk程序很容易使用系统资源.&lt;br&gt;
由于awk具有上述特色, 在问题处理的过程中, 可轻易使用awk来撰写一些小工具; 这些小工具并非用来解决整个大问题,它们只扮演解决个别问题过程的某些角色, 可藉由Shell所提供的pipe将数据按需要传送给不同的小工具进行处理, 以解决整个大问题. 这种解题方式, 使得这些小工具可因不同需求而被重复组合及重用(reuse); 也可藉此方式来先行测试大程序原型的可行性与正确性, 将来若需要较高的执行速度时再用C语言来改写.这是awk最常被应用之处. 若能常常如此处理问题, 读者可以以更高的角度来思考抽象的问题, 而不会被拘泥于细节的部份.&lt;br&gt;
本手册为awk入门的学习指引, 其内容将先强调如何撰写awk程序,未列入进一步解题方式的应用实例, 这部分将留待UNIX进阶手册中再行讨论.&lt;/p&gt;
&lt;h3 id=&#34;如何取得awk&#34;&gt;如何取得awk&lt;/h3&gt;
&lt;p&gt;一般的UNIX操作系统, 本身即附有awk. 不同的UNIX操作系统&lt;br&gt;
所附的awk其版本亦不尽相同. 若读者所使用的系统上未附有awk,&lt;br&gt;
可透过 anonymous ftp 到下列地方取得 :&lt;br&gt;
phi.sinica.edu.tw:/pub/gnu&lt;br&gt;
ftp.edu.tw:/UNIX/gnu&lt;br&gt;
prep.ai.mit.edu:/pub/gnu&lt;/p&gt;
&lt;h3 id=&#34;awk如何工作&#34;&gt;awk如何工作&lt;/h3&gt;
&lt;p&gt;为便于解释awk程序架构, 及有关术语(terminology), 先以一个员工薪资档(emp.dat ), 来加以介绍.&lt;br&gt;
A125 Jenny 100 210&lt;br&gt;
A341 Dan 110 215&lt;br&gt;
P158 Max 130 209&lt;br&gt;
P148 John 125 220&lt;br&gt;
A123 Linda 95 210&lt;br&gt;
文件中各字段依次为 员工ID, 姓名, 薪资率,及 实际工时. ID中的第一码为部门识别码. &amp;ldquo;A&amp;rdquo;,&amp;ldquo;P&amp;quot;分别表示&amp;quot;组装&amp;quot;及&amp;quot;包装&amp;quot;部门.&lt;br&gt;
本小节着重于说明awk程序的主要架构及工作原理, 并对一些重要的名词辅以必要的解释. 由这部分内容, 读者可体会出awk语言的主要精神及awk与其它语程序言的差异处. 为便于说明, 以条列方式说明于后.&lt;/p&gt;
&lt;h3 id=&#34;名词定义&#34;&gt;名词定义&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;数据行&lt;/strong&gt;&lt;/em&gt;: awk从数据文件上读取数据的基本单位.以上列文件emp.dat为例, awk读入的&lt;br&gt;
第一笔数据行是 &amp;ldquo;A125 Jenny 100 210&amp;rdquo;&lt;br&gt;
第二笔数据行是 &amp;ldquo;A341 Dan 110 215&amp;rdquo;&lt;br&gt;
一般而言, 一个 数据行 就相当于数据文件上的一行资料. (参考 : 附录 B 内建变量&amp;quot;RS&amp;rdquo; )&lt;br&gt;
&lt;em&gt;&lt;strong&gt;字段(Field)&lt;/strong&gt;&lt;/em&gt; : 为数据行上被分隔开的子字符串.&lt;br&gt;
以数据行&amp;quot;A125 Jenny 100 210&amp;quot;为例,&lt;br&gt;
第一栏 第二栏 第三栏 第四栏 &amp;ldquo;A125&amp;rdquo; &amp;ldquo;Jenny&amp;rdquo; 100 210&lt;br&gt;
一般是以空格符来分隔相邻的字段. ( 参考 : 附录 D 内建变量&amp;quot;FS&amp;quot; )&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3. 如何执行awk</title>
      <link>https://wukong.tongji.edu.cn/internal/zhuqianshu.awk-best-manual/3/</link>
      <pubDate>Mon, 21 Dec 2020 00:00:00 +0000</pubDate>
      <guid>https://wukong.tongji.edu.cn/internal/zhuqianshu.awk-best-manual/3/</guid>
      <description>&lt;p&gt;于UNIX的命令行上键入诸如下列格式的指令: ( &amp;ldquo;$&amp;ldquo;表Shell命令行上的提示符号)&lt;/p&gt;
&lt;h3 id=&#34;awk-awk程序-数据文件文件名&#34;&gt;&lt;code&gt;$awk &#39;awk程序&#39; 数据文件文件名&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;则awk会先编译该程序, 然后执行该程序来处理所指定的数据文件.&lt;br&gt;
(上列方式系直接把程序写在UNIX的命令行上)&lt;/p&gt;
&lt;h3 id=&#34;awk程序的主要结构&#34;&gt;awk程序的主要结构:&lt;/h3&gt;
&lt;p&gt;awk程序中主要语法是 Pattern { Actions}, 故常见之awk 程序其型态如下 :&lt;br&gt;
Pattern1 { Actions1 }&lt;br&gt;
Pattern2 { Actions2 }&lt;br&gt;
&amp;hellip;&amp;hellip;&lt;br&gt;
Pattern3 { Actions3 }&lt;/p&gt;
&lt;h3 id=&#34;pattern-是什么-&#34;&gt;Pattern 是什么 ?&lt;/h3&gt;
&lt;p&gt;awk 可接受许多不同型态的 Pattern. 一般常使用 &amp;ldquo;关系表达式&amp;rdquo;(Relational expression) 来当成 Pattern.&lt;br&gt;
例如:&lt;br&gt;
x &amp;gt; 34 是一个Pattern, 判断变量 x 与 34 是否存在大于的关系.&lt;br&gt;
x == y 是一个Pattern, 判断变量 x 与变量 y 是否存在等于的关系.&lt;br&gt;
上式中 x &amp;gt;34 , x == y 便是典型的Pattern.&lt;br&gt;
awk 提供 C 语言中常见的关系运算符(Relational Operators) 如&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;, &amp;lt;, &amp;gt;=, &amp;lt;=, ==, !=&lt;br&gt;
此外, awk 还提供 ~ (match) 及 !~(not match) 二个关系运算符(注一).&lt;br&gt;
其用法与涵义如下:&lt;br&gt;
若 A 为一字符串, B 为一正则表达式(Regular Expression)&lt;br&gt;
A ~ B 判断 字符串A 中是否 包含 能匹配(match)B表达式的子字符串.&lt;br&gt;
A !~ B 判断 字符串A 中是否 不包含 能匹配(match)B表达式的子字符串.&lt;br&gt;
例如 :&lt;br&gt;
&amp;ldquo;banana&amp;rdquo; ~ /an/ 整个是一个Pattern.&lt;br&gt;
因为&amp;quot;banana&amp;quot;中含有可以匹配 /an/ 的子字符串, 故此关系式成立(true),整个Pattern的值也是true.&lt;br&gt;
相关细节请参考 附录 A Patterns, 附录 E Regular Expression&lt;br&gt;
(注一:) 有少数awk论著, 把 ~, !~ 当成另一类的 Operator,并不视为一种 Relational Operator. 本手册中将这两个运算符当成一种 Relational Operator.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;actions-是什么&#34;&gt;Actions 是什么?&lt;/h3&gt;
&lt;p&gt;Actions 是由许多awk指令构成. 而awk的指令与 C 语言中的指令十分类似.&lt;br&gt;
例如 :&lt;br&gt;
awk的 I/O指令 : print, printf( ), getline&amp;hellip;&lt;br&gt;
awk的 流程控制指令 : if(&amp;hellip;){..} else{..}, while(&amp;hellip;){&amp;hellip;}&amp;hellip;&lt;br&gt;
(请参考 附录 B &amp;mdash; &amp;ldquo;Actions&amp;rdquo; )&lt;/p&gt;
&lt;h3 id=&#34;awk-如何处理-pattern--actions--&#34;&gt;awk 如何处理 Pattern { Actions } ?&lt;/h3&gt;
&lt;p&gt;awk 会先判断(Evaluate) 该 Pattern 的值, 若 Pattern 判断后的值为true (或不为0的数字,或不是空的字符串), 则 awk将执行该 Pattern 所对应的 Actions.反之, 若 Pattern 之值不为 true, 则awk将不执行该 Pattern所对应的 Actions.&lt;/p&gt;
&lt;p&gt;例如 : 若awk程序中有下列两指令&lt;br&gt;
50 &amp;gt; 23 {print &amp;ldquo;Hello! The word!!&amp;rdquo; }&lt;br&gt;
&amp;ldquo;banana&amp;rdquo; ~ /123/ { print &amp;ldquo;Good morning !&amp;rdquo; }&lt;br&gt;
awk会先判断 50 &amp;gt;23 是否成立. 因为该式成立, 所以awk将印出&amp;quot;Hello! The word!!&amp;rdquo;. 而另一 Pattern 为 &amp;ldquo;banana&amp;rdquo; ~/123/, 因为&amp;quot;banana&amp;rdquo; 内未含有任何子字符串可 match /123/,该 Pattern 之值为false, 故awk将不会印出 &amp;ldquo;Good morning !&amp;rdquo;&lt;/p&gt;
&lt;h3 id=&#34;awk-如何处理-actions--的语法缺少pattern部分&#34;&gt;awk 如何处理{ Actions } 的语法?(缺少Pattern部分)&lt;/h3&gt;
&lt;p&gt;有时语法 Pattern { Actions }中, Pattern 部分被省略,只剩 {Actions}.这种情形表示 &amp;ldquo;无条件执行这个 Actions&amp;rdquo;.&lt;/p&gt;
&lt;h3 id=&#34;awk-的字段变量&#34;&gt;awk 的字段变量&lt;/h3&gt;
&lt;p&gt;awk 所内建的字段变量及其涵意如下 :&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字段变量&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$0&lt;/td&gt;
&lt;td&gt;一字符串, 其内容为目前 awk 所读入的数据行.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$1&lt;/td&gt;
&lt;td&gt;$0 上第一个字段的数据.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$2&lt;/td&gt;
&lt;td&gt;$0 上第二个字段的数据.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;hellip;&lt;/td&gt;
&lt;td&gt;其余类推&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;读入数据行时-awk如何更新update这些内建的字段变量&#34;&gt;读入数据行时, awk如何更新(update)这些内建的字段变量?&lt;/h3&gt;
&lt;p&gt;当 awk 从数据文件中读取一个数据行时, awk 会使用内建变量$0 予以记录.每当 $0 被改动时 (例如 : 读入新的数据行 或 自行变更 $0,&amp;hellip;) awk 会立刻重新分析 $0 的字段情况, 并将$0 上各字段的数据用 $1, $2, ..予以记录.&lt;/p&gt;
&lt;h3 id=&#34;awk的内建变量built-in-variables&#34;&gt;awk的内建变量(Built-in Variables)&lt;/h3&gt;
&lt;p&gt;awk 提供了许多内建变量, 使用者于程序中可使用这些变量来取得相关信息.常见的内建变量有 :&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;内建变量&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;NF (Number of Fields)&lt;/td&gt;
&lt;td&gt;为一整数, 其值表$0上所存在的字段数目.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NR (Number of Records)&lt;/td&gt;
&lt;td&gt;为一整数, 其值表awk已读入的数据行数目.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FILENAME&lt;/td&gt;
&lt;td&gt;正在处理的数据文件文件名.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;例如 : awk 从资料文件 emp.dat 中读入第一笔数据行&lt;br&gt;
&amp;ldquo;A125 Jenny 100 210&amp;rdquo; 之后, 程序中:&lt;br&gt;
$0 之值将是 &amp;ldquo;A125 Jenny 100 210&amp;rdquo;&lt;br&gt;
$1 之值为 &amp;ldquo;A125&amp;rdquo;&lt;br&gt;
$2 之值为 &amp;ldquo;Jenny&amp;rdquo;&lt;br&gt;
$3 之值为 100&lt;br&gt;
$4 之值为 210&lt;br&gt;
$NF 之值为 4&lt;br&gt;
$NR 之值为 1&lt;br&gt;
$FILENAME 之值为 &amp;ldquo;emp.dat&amp;rdquo;&lt;/p&gt;
&lt;h3 id=&#34;awk的工作流程-&#34;&gt;awk的工作流程 :&lt;/h3&gt;
&lt;p&gt;执行awk时, 它会反复进行下列四步骤.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自动从指定的数据文件中读取一个数据行.&lt;/li&gt;
&lt;li&gt;自动更新(Update)相关的内建变量之值. 如 : NF, NR, $0&amp;hellip;&lt;/li&gt;
&lt;li&gt;依次执行程序中 所有 的 Pattern { Actions } 指令.&lt;/li&gt;
&lt;li&gt;当执行完程序中所有 Pattern { Actions } 时, 若数据文件中还有未读取的数据, 则反复执行步骤1到步骤4.&lt;br&gt;
awk会自动重复进行上述4个步骤, 使用者不须于程序中编写这个循环 (Loop).&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;打印文件中指定的字段数据并加以计算&#34;&gt;打印文件中指定的字段数据并加以计算&lt;/h3&gt;
&lt;p&gt;awk 处理数据时, 它会自动从数据文件中一次读取一笔记录, 并会&lt;br&gt;
将该数据切分成一个个的字段; 程序中可使用 $1, $2,&amp;hellip; 直接取得&lt;br&gt;
各个字段的内容. 这个特色让使用者易于用 awk 编写 reformatter 来改变量据格式.&lt;br&gt;
[ 范例 :] 以文件 emp.dat 为例, 计算每人应发工资并打印报表.&lt;br&gt;
[ 分析 :] awk 会自行一次读入一列数据, 故程序中仅需告诉&lt;br&gt;
awk 如何处理所读入的数据行.&lt;br&gt;
执行如下命令 : ( $ 表UNIX命令行上的提示符 )&lt;/p&gt;
&lt;h3 id=&#34;-awk--print-2-3--4--empdat&#34;&gt;&lt;code&gt;$ awk &#39;{ print $2, $3 * $4 }&#39; emp.dat&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;执行结果如下 :&lt;br&gt;
屏幕出现 :&lt;br&gt;
Jenny 21000&lt;br&gt;
Dan 23650&lt;br&gt;
Max 27170&lt;br&gt;
John 27500&lt;br&gt;
Linda 19950&lt;/p&gt;
&lt;p&gt;[ 说明 :]&lt;br&gt;
UNIX命令行上, 执行awk的语法为:&lt;br&gt;
$awk &amp;lsquo;awk程序&amp;rsquo; 欲处理的资料文件文件名&lt;br&gt;
本范例中的 程序部分 为 {print $2, $3 * $4}.&lt;br&gt;
把程序置于命令行时, 程序之前后须以 &#39; 括住.&lt;br&gt;
emp.dat 为指定给该程序处理的数据文件文件名.&lt;/p&gt;
&lt;p&gt;本程序中使用 : Pattern { Actions } 语法.&lt;br&gt;
Pattern 部分被省略, 表无任何限制条件. 故awk读入每笔数据行后都将无条件执行这个 Actions.&lt;br&gt;
print为awk所提供的输出指令, 会将数据输出到stdout(屏幕).&lt;br&gt;
print 的参数间彼此以 &amp;ldquo;,&amp;rdquo; (逗号) 隔开, 印出数据时彼此间会以空白隔开. (参考 附录 D 内建变量OFS)&lt;br&gt;
将上述的 程序部分 储存于文件 pay1.awk 中. 执行命令时再指定awk程序文件 之文件名. 这是执行awk的另一种方式, 特别适用于程序较大的情况, 其语法如下:&lt;br&gt;
$ awk -f awk程序文件名 数据文件文件名&lt;br&gt;
故执行下列两命令,将产生同样的结果.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ awk -f pay1.awk emp.dat  
$ awk &#39;{ print $2, $3 * $4 }&#39; emp.dat  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;读者可使用 &amp;ldquo;-f&amp;rdquo; 参数,让awk主程序使用“其它仅含 awk函数 的文件中的函数 ”&lt;br&gt;
其语法如下:&lt;br&gt;
$ awk -f awk主程序文件名 -f awk函数文件名 数据文件文件名&lt;br&gt;
(有关 awk 中函数的声明与使用于 7.4 中说明)&lt;br&gt;
awk中也提供与 C 语言中类似用法的 printf() 函数. 使用该函数可进一步控制数据的输出格式.&lt;br&gt;
编辑另一个awk程序如下, 并取名为 pay2.awk&lt;/p&gt;
&lt;p&gt;{ printf(&amp;quot;%6s Work hours: %3d Pay: %5d\n&amp;quot;, $2,$3, $3* $4) }&lt;br&gt;
执行下列命令&lt;/p&gt;
&lt;p&gt;$awk -f pay2.awk emp.dat&lt;/p&gt;
&lt;p&gt;执行结果屏幕出现:&lt;br&gt;
Jenny Work hours: 100 Pay: 21000&lt;br&gt;
Dan Work hours: 110 Pay: 23650&lt;br&gt;
Max Work hours: 130 Pay: 27170&lt;br&gt;
John Work hours: 125 Pay: 27500&lt;br&gt;
Linda Work hours:  95 Pay: 19950&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>4. 选择符合指定条件的记录  </title>
      <link>https://wukong.tongji.edu.cn/internal/zhuqianshu.awk-best-manual/4/</link>
      <pubDate>Mon, 21 Dec 2020 00:00:00 +0000</pubDate>
      <guid>https://wukong.tongji.edu.cn/internal/zhuqianshu.awk-best-manual/4/</guid>
      <description>&lt;p&gt;Pattern { Action }为awk中最主要的语法. 若某Pattern之值为真则执行它后方的 Action. awk中常使用&amp;quot;关系表达式&amp;quot; (Relational Expression)来当成 Pattern.&lt;br&gt;
awk 中除了&amp;gt;, &amp;lt;, ==, != ,&amp;hellip;等关系运算符( Relational Operators )外,另外提供 ~(match),!~(Not Match) 二个关系运算符. 利用这两个运算符, 可判断某字符串是否包含能匹配所指定正则表达式的子字符串. 由于这些特性, 很容易使用awk来编写需要字符串比对, 判断的程序.&lt;br&gt;
[ 范例 :] 承上例,&lt;br&gt;
组装部门员工调薪5%,(组装部门员工之ID以&amp;quot;A&amp;quot;开头)&lt;br&gt;
所有员工最后之薪资率若仍低于100, 则以100计.&lt;br&gt;
编写awk程序打印新的员工薪资率报表.&lt;br&gt;
[分析 ] : 这个程序须先判断所读入的数据行是否合于指定条件, 再进行某些动作.awk中 Pattern { Actions } 的语法已涵盖这种 &amp;quot; if ( 条件) { 动作} &amp;ldquo;的架构. 编写如下之程序, 并取名adjust1.awk&lt;br&gt;
$1 ~ /^A.&lt;em&gt;/ { $3 &lt;em&gt;= 1.05 } $3&amp;lt;100 { $3 = 100 }&lt;br&gt;
{ printf(&amp;quot;%s %8s %d\n&amp;rdquo;, $1, $2, $3)}&lt;br&gt;
执行下列命令 :&lt;br&gt;
$awk -f adjust1.awk emp.dat&lt;br&gt;
结果如下 : 屏幕出现 :&lt;br&gt;
A125    Jenny 105&lt;br&gt;
A341      Dan 115&lt;br&gt;
P158      Max 130&lt;br&gt;
P148     John 125&lt;br&gt;
A123    Linda 100&lt;br&gt;
说 明 :&lt;br&gt;
awk的工作程序是: 从数据文件中每次读入一个数据行, 依序执行完程序中所有的 Pattern{ Action }指令:&lt;br&gt;
$1~/^A.&lt;/em&gt;/ { $3 &lt;em&gt;= 1.05 }&lt;br&gt;
$3 &amp;lt; 100 { $3 = 100 }&lt;br&gt;
{printf(&amp;quot;%s %8s %d\n&amp;quot;,$1,$2,$3)}&lt;br&gt;
再从数据文件中读进下一笔记录继续进行处理.&lt;br&gt;
第一个 Pattern { Action }是: $1 ~ /^A.&lt;/em&gt;/ { $3 &lt;em&gt;= 1.05 }&lt;br&gt;
$1 ~ /^A.&lt;/em&gt;/ 是一个Pattern, 用来判断该笔数据行的第一栏是否包含以&amp;quot;A&amp;quot;开头的子字符串. 其中 /^A.&lt;/em&gt;/ 是一个Regular Expression, 用以表示任何以&amp;quot;A&amp;quot;开头的字符串. (有关 Regular Expression 之用法 参考 附录 E ).&lt;br&gt;
Actions 部分为 $3 *= 1.05&lt;br&gt;
$3 &lt;em&gt;= 1.05 与 $3 = $3 * 1.05 意义相同. 运算子&amp;quot;&lt;/em&gt;=&amp;quot; 之用法则与 C 语言中一样. 此后与 C 语言中用法相同的运算子或语法将不予赘述.&lt;/p&gt;
&lt;p&gt;第二个 Pattern { Actions } 是: $3 &amp;lt;100 {$3 = 100 } 若第三栏的数据内容(表薪资率)小于100, 则调整为100.&lt;br&gt;
第三个 Pattern { Actions } 是: {printf(&amp;quot;%s %8s %d\n&amp;quot;,$1, $2, $3 )} 省略了Pattern(无条件执行Actions), 故所有数据行调整后的数据都将被印出.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>5. awk 中数组</title>
      <link>https://wukong.tongji.edu.cn/internal/zhuqianshu.awk-best-manual/5/</link>
      <pubDate>Mon, 21 Dec 2020 00:00:00 +0000</pubDate>
      <guid>https://wukong.tongji.edu.cn/internal/zhuqianshu.awk-best-manual/5/</guid>
      <description>&lt;p&gt;awk程序中允许使用字符串当做数组的下标(index). 利用这个特色十分有助于资料统计工作.(使用字符串当下标的数组称为Associative Array)&lt;br&gt;
首先建立一个数据文件, 并取名为 reg.dat. 此为一学生注册的资料文件; 第一栏为学生姓名, 其后为该生所修课程.&lt;br&gt;
Mary O.S. Arch. Discrete&lt;br&gt;
Steve D.S. Algorithm Arch.&lt;br&gt;
Wang Discrete Graphics O.S.&lt;br&gt;
Lisa Graphics A.I.&lt;br&gt;
Lily Discrete Algorithm&lt;/p&gt;
&lt;h3 id=&#34;awk中数组的特性&#34;&gt;awk中数组的特性&lt;/h3&gt;
&lt;p&gt;使用字符串当数组的下标(index).&lt;br&gt;
使用数组前不须宣告数组名及其大小.&lt;br&gt;
例如: 希望用数组来记录 reg.dat 中各门课程的修课人数.&lt;br&gt;
这情况,有二项信息必须储存:&lt;br&gt;
(a) 课程名称, 如: &amp;ldquo;O.S.&amp;rdquo;,&amp;ldquo;Arch.&amp;rdquo;.. ,共有哪些课程事先并不明确.&lt;br&gt;
(b)各课程的修课人数. 如: 有几个人修&amp;quot;O.S.&amp;quot;&lt;br&gt;
在awk中只要用一个数组就可同时记录上列信息. 其方法如下:&lt;br&gt;
使用一个数组 Number[ ] :&lt;br&gt;
以课程名称当 Number[ ] 的下标.&lt;br&gt;
以 Number[ ] 中不同下标所对映的元素代表修课人数.&lt;br&gt;
例如:&lt;br&gt;
有2个学生修 &amp;ldquo;O.S.&amp;rdquo;, 则以 Number[&amp;ldquo;O.S.&amp;quot;] = 2 表之.&lt;br&gt;
若修&amp;quot;O.S.&amp;ldquo;的人数增加一人,则 Number[&amp;ldquo;O.S.&amp;quot;] = Number[&amp;ldquo;O.S.&amp;quot;] + 1 或 Number[&amp;ldquo;O.S.&amp;quot;]++ .&lt;/p&gt;
&lt;h3 id=&#34;如何取出数组中储存的信息&#34;&gt;如何取出数组中储存的信息&lt;/h3&gt;
&lt;p&gt;以 C 语言为例, 声明 int Arr[100]; 之后, 若想得知 Arr[ ]中所储存的数据, 只须用一个循环, 如 :&lt;br&gt;
for(i=0; i&amp;lt;100; i++) printf(&amp;quot;%d\n&amp;rdquo;, Arr[i]);&lt;br&gt;
即可. 上式中:&lt;br&gt;
数组 Arr[ ] 的下标 : 0, 1, 2,&amp;hellip;, 99&lt;br&gt;
数组 Arr[ ] 中各下标所对应的值 : Arr[0], Arr[1],&amp;hellip;Arr[99]&lt;br&gt;
但 awk 中使用数组并不须事先宣告. 以刚才使用的 Number[ ] 而言, 程序执行前, 并不知将来有哪些课程名称可能被当成 Number[ ] 的下标.&lt;br&gt;
awk 提供了一个指令, 藉由该指令awk会自动找寻数组中使用过的所有下标. 以 Number[ ] 为例, awk将会找到 &amp;ldquo;O.S.&amp;rdquo;, &amp;ldquo;Arch.&amp;rdquo;,&amp;hellip;&lt;br&gt;
使用该指令时, 须指定所要找寻的数组, 及一个变量. awk会使用该的变量来记录从数组中找到的每一个下标. 例如&lt;br&gt;
for(course in Number){&amp;hellip;.}&lt;br&gt;
指定用 course 来记录 awk 从Number[ ] 中所找到的下标. awk每找到一个下标时, 就用course记录该下标之值且执行{&amp;hellip;.}中之指令. 藉由这个方式便可取出数组中储存的信息.&lt;br&gt;
(详见下例)&lt;br&gt;
[ 范例 : ] 统计各科修课人数,并印出结果.&lt;br&gt;
建立如下程序,并取名为 course.awk:&lt;br&gt;
{ for( i=2; i &amp;lt;= NF; i++) Number[$i]++ }&lt;br&gt;
END{for(course in Number) printf(&amp;quot;%10s %d\n&amp;rdquo;, course, Number[course] )}&lt;br&gt;
执行下列命令 :&lt;br&gt;
$awk -f course.awk reg.dat&lt;br&gt;
执行结果如下 :&lt;br&gt;
Graphics 2&lt;br&gt;
O.S. 2&lt;br&gt;
Discrete 3&lt;br&gt;
A.I. 1&lt;br&gt;
D.S. 1&lt;br&gt;
Arch. 2&lt;br&gt;
Algorithm 2&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[ 说 明 : ]&lt;br&gt;
这程序包含二个Pattern { Actions }指令.&lt;br&gt;
{ for( i=2; i &amp;lt;= NF; i++) Number[$i]++ }&lt;br&gt;
END{for(course in Number) printf(&amp;quot;%10s %d\n&amp;rdquo;, course, Number[course] )}&lt;br&gt;
第一个Pattern { Actions }指令中省略了Pattern 部分. 故随着&lt;br&gt;
每笔数据行的读入其Actions部分将逐次无条件被执行.&lt;br&gt;
以awk读入第一笔资料 &amp;quot; Mary O.S. Arch. Discrete&amp;rdquo; 为例, 因为该笔数据 NF = 4(有4个字段), 故该 Action 的for Loop中i = 2,3,4.&lt;br&gt;
i $i 最初 Number[$i] Number[$i]++ 之后&lt;br&gt;
i=2时 $i=&amp;ldquo;O.S.&amp;rdquo; Number[&amp;ldquo;O.S.&amp;quot;]的值从默认的0,变成了1 ;&lt;br&gt;
i=3时 $i=&amp;ldquo;Arch.&amp;rdquo; Number[&amp;ldquo;Arch.&amp;quot;]的值从默认的0,变成了1 ;&lt;br&gt;
同理,i=4时 $i=&amp;ldquo;Discrete&amp;rdquo; Number[&amp;ldquo;Discrete&amp;rdquo;]的值从默认的0,变成了1 ;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;第二个 Pattern { Actions }指令中END 为awk之保留字, 为 Pattern 的一种.&lt;br&gt;
END 成立(其值为true)的条件是: &amp;ldquo;awk处理完所有数据, 即将离开程序时. &amp;quot;&lt;br&gt;
平常读入数据行时, END并不成立, 故其后的Actions 并不被执行;&lt;br&gt;
唯有当awk读完所有数据时, 该Actions才会被执行 ( 注意, 不管数据行有多少笔, END仅在最后才成立, 故该Actions仅被执行一次.)&lt;br&gt;
BEGIN 与 END 有点类似, 是awk中另一个保留的Pattern.&lt;br&gt;
唯一不同的是: &amp;ldquo;以 BEGIN 为 Pattern 的 Actions 于程序一开始执行时, 被执行一次.&amp;rdquo;&lt;br&gt;
NF 为awk的内建变量, 用以表示awk正处理的数据行中, 所包含的字段个数.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;awk程序中若含有以 $ 开头的自定变量, 都将以如下方式解释 :&lt;br&gt;
以 i= 2 为例, $i = $2 表第二个字段数据. ( 实际上, $ 在 awk 中为一运算符(Operator), 用以取得字段数据.)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>6. awk 程序中使用 Shell 命令 </title>
      <link>https://wukong.tongji.edu.cn/internal/zhuqianshu.awk-best-manual/6/</link>
      <pubDate>Mon, 21 Dec 2020 00:00:00 +0000</pubDate>
      <guid>https://wukong.tongji.edu.cn/internal/zhuqianshu.awk-best-manual/6/</guid>
      <description>&lt;p&gt;awk程序中允许呼叫Shell指令. 并提供管道解决awk与系统间数据传递的问题. 所以awk很容易使用系统资源. 读者可利用这个特点来编写某些适用的系统工具.&lt;br&gt;
[ 范例 : ] 写一个awk程序来打印出线上人数.&lt;br&gt;
将下列程序建文件, 命名为 count.awk&lt;br&gt;
BEGIN {&lt;br&gt;
while ( &amp;ldquo;who&amp;rdquo; | getline ) n++&lt;br&gt;
print n&lt;br&gt;
}&lt;br&gt;
并执行下列命令 :&lt;br&gt;
awk -f count.awk&lt;br&gt;
执行结果将会印出目前在线人数&lt;br&gt;
[ 说 明 : ]&lt;br&gt;
awk 程序并不一定要处理数据文件. 以本例而言, 仅输入程序文件count.awk, 未输入任何数据文件.&lt;br&gt;
BEGIN 和 END 同为awk中的一种 Pattern. 以 BEGIN 为 Pattern的Actions ,只有在awk开始执行程序,尚未开启任何输入文件前, 被执行一次.(注意: 只被执行一次)&lt;br&gt;
&amp;ldquo;|&amp;rdquo; 为 awk 中表示管道的符号. awk 把 | 之前的字符串&amp;quot;who&amp;quot;当成Shell上的命令, 并将该命令送往Shell执行, 执行的结果(原先应于屏幕印出者)则藉由pipe送进awk程序中.&lt;br&gt;
getline为awk所提供的输入指令.&lt;br&gt;
其语法如下 :&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;语法&lt;/th&gt;
&lt;th&gt;由何处读取数据数据&lt;/th&gt;
&lt;th&gt;读入后置于&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;getline var &amp;lt; file&lt;/td&gt;
&lt;td&gt;所指定的 file&lt;/td&gt;
&lt;td&gt;变量 var(var省略时,表示置于$0)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;getline var&lt;/td&gt;
&lt;td&gt;pipe 变量&lt;/td&gt;
&lt;td&gt;变量 var(var省略时,表示置于$0)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;getline var&lt;/td&gt;
&lt;td&gt;见 注一&lt;/td&gt;
&lt;td&gt;变量 var(var省略时,表示置于$0)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;注一 : 当 Pattern 为 BEGIN 或 END 时, getline 将由 stdin 读取数据, 否则由awk正处理的数据文件上读取数据.&lt;br&gt;
getline 一次读取一行数据, 若读取成功则return 1, 若读取失败则return -1, 若遇到文件结束(EOF), 则return 0;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本程序使用 getline 所 return 的数据来做为 while 判断循环停止的条件,某些awk版本较旧,并不容许使用者改变 $0 之值. 这种版的 awk 执行本程序时会产生 Error, 读者可于 getline之后置上一个变量 (如此, getline 读进来的数据便不会被置于 $0 ), 或直接改用gawk便可解决.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>7. awk 程序的应用实例  </title>
      <link>https://wukong.tongji.edu.cn/internal/zhuqianshu.awk-best-manual/7/</link>
      <pubDate>Mon, 21 Dec 2020 00:00:00 +0000</pubDate>
      <guid>https://wukong.tongji.edu.cn/internal/zhuqianshu.awk-best-manual/7/</guid>
      <description>&lt;p&gt;本节将示范一个统计上班到达时间及迟到次数的程序.&lt;br&gt;
这程序每日被执行时将读入二个文件:&lt;br&gt;
员工当日到班时间的数据文件 ( 如下列之 arr.dat )&lt;br&gt;
存放员工当月迟到累计次数的文件.&lt;br&gt;
当程序执行执完毕后将更新第二个文件的数据(迟到次数), 并打印当日的报表.这程序将分成下列数小节逐步完成, 其大纲如下:&lt;/p&gt;
&lt;h3 id=&#34;71-在到班资料文件-arrdat-之前增加一行抬头&#34;&gt;[7.1] 在到班资料文件 arr.dat 之前增加一行抬头&lt;/h3&gt;
&lt;p&gt;&amp;ldquo;ID Number Arrvial Time&amp;rdquo;, 并产生报表输出到文件today_rpt1 中.&lt;br&gt;
&amp;lt; 思考: 在awk中如何将数据输出到文件 &amp;gt;&lt;/p&gt;
&lt;h3 id=&#34;72将-today_rpt1-上的数据按员工代号排序-并加注执行当日日期-产生文件-today_rpt2&#34;&gt;[7.2]将 today_rpt1 上的数据按员工代号排序, 并加注执行当日日期; 产生文件 today_rpt2&lt;/h3&gt;
&lt;p&gt;&amp;lt;思考 awk中如何运用系统资源及awk中Pipe之特性 &amp;gt;&lt;/p&gt;
&lt;h3 id=&#34;73-将awk程序包含在一个shell-script文件中&#34;&gt;[7.3] 将awk程序包含在一个shell script文件中&lt;/h3&gt;
&lt;h3 id=&#34;74-于-today_rpt2-每日报表上-迟到者之前加上-并加注当日平均到班时间&#34;&gt;[7.4] 于 today_rpt2 每日报表上, 迟到者之前加上&amp;quot;*&amp;quot;, 并加注当日平均到班时间;&lt;/h3&gt;
&lt;p&gt;产生文件 today_rpt3&lt;/p&gt;
&lt;h3 id=&#34;75-从文件中读取当月迟到次数-并根据当日出勤状况更新迟到累计数&#34;&gt;[7.5] 从文件中读取当月迟到次数, 并根据当日出勤状况更新迟到累计数.&lt;/h3&gt;
&lt;p&gt;&amp;lt;思考 使用者在awk中如何读取文件数据 &amp;gt;&lt;/p&gt;
&lt;p&gt;某公司其员工到勤时间档如下, 取名为 arr.dat. 文件中第一栏为员工代号, 第二栏为到达时间. 本范例中, 将使用该文件为数据文件.&lt;br&gt;
1034 7:26&lt;br&gt;
1025 7:27&lt;br&gt;
1101 7:32&lt;br&gt;
1006 7:45&lt;br&gt;
1012 7:46&lt;br&gt;
1028 7:49&lt;br&gt;
1051 7:51&lt;br&gt;
1029 7:57&lt;br&gt;
1042 7:59&lt;br&gt;
1008 8:01&lt;br&gt;
1052 8:05&lt;br&gt;
1005 8:12&lt;/p&gt;
&lt;h3 id=&#34;重定向输出到文件&#34;&gt;重定向输出到文件&lt;/h3&gt;
&lt;p&gt;awk中并未提供如 C 语言中之fopen() 指令, 也未有fprintf() 文件输出这样的指令. 但awk中任何输出函数之后皆可借助使用与UNIX 中类似的 I/O 重定向符, 将输出的数据重定向到指定的文件; 其符号仍为 &amp;gt; (输出到一个新产生的文件) 或 &amp;raquo; ( 添加输出的数据到文件末尾 ).&lt;/p&gt;
&lt;h4 id=&#34;例-&#34;&gt;[例 :]&lt;/h4&gt;
&lt;h1 id=&#34;id-number-arrival-time&#34;&gt;在到班数据文件 arr.dat 之前增加一行抬头如下:&lt;br&gt;
&amp;ldquo;ID Number Arrival Time&amp;rdquo;, 并产生报表输出到文件 today_rpt1中&lt;br&gt;
建立如下文件并取名为reformat1.awk&lt;br&gt;
BEGIN { print &amp;quot; ID Number Arrival Time&amp;quot; &amp;gt; &amp;ldquo;today_rpt1&amp;rdquo;&lt;br&gt;
print &amp;ldquo;===========================&amp;rdquo; &amp;gt; &amp;ldquo;today_rpt1&amp;rdquo;&lt;br&gt;
}&lt;br&gt;
{ printf(&amp;quot; %s %s\n&amp;quot;, $1,$2 ) &amp;gt; &amp;ldquo;today_rpt1&amp;rdquo; }&lt;br&gt;
执行:&lt;br&gt;
$awk -f reformat1.awk arr.dat&lt;br&gt;
执行后将产生文件 today_rpt1, 其内容如下 :&lt;br&gt;
ID Number Arrival Time&lt;/h1&gt;
&lt;p&gt;1034 7:26&lt;br&gt;
1025 7:27&lt;br&gt;
1101 7:32&lt;br&gt;
1006 7:45&lt;br&gt;
1012 7:46&lt;br&gt;
1028 7:49&lt;br&gt;
1051 7:51&lt;br&gt;
1029 7:57&lt;br&gt;
1042 7:59&lt;br&gt;
1008 8:01&lt;br&gt;
1052 8:05&lt;br&gt;
1005 8:12&lt;/p&gt;
&lt;h4 id=&#34;-说-明---&#34;&gt;[ 说 明 :  ]&lt;/h4&gt;
&lt;p&gt;awk程序中, 文件名称 today_rpt1 的前后须以&amp;quot; (双引号)括住, 表示 today_rpt1 为一字符串常量. 若未以&amp;quot;括住, 则 today_rpt1 将被awk解释为一个变量名称.&lt;br&gt;
在awk中任何变量使用之前, 并不须事先声明. 其初始值为空字符串(Null string) 或 0.因此程序中若未以 &amp;quot; 将 today_rpt1 括住, 则 today_rpt1 将是一变量, 其值将是空字符串, 这会在执行时造成错误(Unix 无法帮您开启一个以空字符串为文件名的文件).&lt;br&gt;
因此在编辑awk程序时, 须格外留心. 因为若敲错变量名称,awk在编译程序时会认为是一新的变量, 并不会察觉. 因此往往会造成运行时错误.&lt;br&gt;
BEGIN 为awk的保留字, 是 Pattern 的一种.&lt;br&gt;
以 BEGIN 为 Pattern 的 Actions 于awk程序刚被执行尚未读取数据文件时被执行一次, 此后便不再被执行.&lt;br&gt;
读者或许觉得本程序中的I/O重定向符号应使用 &amp;quot; &amp;raquo;&amp;quot; (append)而非 &amp;quot; &amp;gt;&amp;quot;.&lt;br&gt;
本程序中若使用 &amp;ldquo;&amp;gt;&amp;rdquo; 将数据重导到 today_rpt1, awk 第一次执行该指令时会产生一个新档 today_rpt1, 其后再执行该指令时则把数据追加到today_rpt1文件末, 并非每执行一次就重开一个新文件.&lt;br&gt;
若采用&amp;quot;&amp;raquo;&amp;ldquo;其差异仅在第一次执行该指令时, 若已存在today_rpt1则 awk 将直接把数据append在原文件之末尾. 这一点, 与UNIX中的用法不同.&lt;/p&gt;
&lt;h3 id=&#34;awk-中如何利用系统资源&#34;&gt;awk 中如何利用系统资源&lt;/h3&gt;
&lt;p&gt;awk程序中很容易使用系统资源. 这包括在程序中途调用 Shell 命令来处理程序中的部分数据; 或在调用 Shell 命令后将其产生的结果交回 awk 程序(不需将结果暂存于某个文件). 这一过程是借助 awk 所提供的管道 (虽然有些类似 Unix 中的管道, 但特性有些不同),及一个从 awk 中呼叫 Unix 的 Shell 命令的语法来达成的.&lt;/p&gt;
&lt;h4 id=&#34;例--1&#34;&gt;[例 :]&lt;/h4&gt;
&lt;p&gt;承上题, 将数据按员工ID排序后再输出到文件 today_rpt2 , 并于表头附加执行时的日期.&lt;/p&gt;
&lt;h4 id=&#34;-分-析--&#34;&gt;[ 分 析 : ]&lt;/h4&gt;
&lt;p&gt;awk 提供与 UNIX 用法近似的 pipe, 其记号亦为 &amp;ldquo;|&amp;rdquo;. 其用法及含意如下 :&lt;br&gt;
awk程序中可接受下列两种语法:&lt;br&gt;
[a. 语法] awk output 指令 | &amp;ldquo;Shell 接受的命令&amp;rdquo;&lt;br&gt;
( 如 : print $1,$2 | &amp;ldquo;sort -k 1&amp;rdquo; )&lt;/p&gt;
&lt;p&gt;[b. 语法] &amp;ldquo;Shell 接受的命令&amp;rdquo; | awk input 指令&lt;br&gt;
( 如 : &amp;ldquo;ls &amp;quot; | getline)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注 : awk input 指令只有 getline 一个.&lt;br&gt;
awk output 指令有 print, printf() 二个.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在a 语法中, awk所输出的数据将转送往 Shell , 由 Shell 的命令进行处理.以上例而言, print 所输出的数据将经由 Shell 命令 &amp;ldquo;sort -k 1&amp;rdquo; 排序后再送往屏幕(stdout).&lt;br&gt;
上列awk程序中, &amp;ldquo;print$1, $2&amp;rdquo; 可能反复执行很多次, 其输出的结果将先暂存于 pipe 中,等到该程序结束时, 才会一并进行 &amp;ldquo;sort -k 1&amp;rdquo;.&lt;br&gt;
须注意二点 : 不论 print $1, $2 被执行几次, &amp;ldquo;sort -k 1&amp;rdquo; 的执行时间是 &amp;ldquo;awk程序结束时&amp;rdquo;,&lt;br&gt;
&amp;ldquo;sort -k 1&amp;rdquo; 的执行次数是 &amp;ldquo;一次&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;在 b 语法中, awk将先调用 Shell 命令. 其执行结果将通过 pipe 送入awk程序,以上例而言, awk先让 Shell 执行 &amp;ldquo;ls&amp;rdquo;,Shell 执行后将结果存于 pipe, awk指令 getline再从 pipe 中读取数据.&lt;br&gt;
使用本语法时应留心: 以上例而言,awk &amp;ldquo;立刻&amp;quot;调用 Shell 来执行 &amp;ldquo;ls&amp;rdquo;, 执行次数是一次.&lt;br&gt;
getline 则可能执行多次(若pipe中存在多行数据).&lt;br&gt;
除上列 a, b 二中语法外, awk程序中其它地方如出现像 &amp;ldquo;date&amp;rdquo;, &amp;ldquo;cls&amp;rdquo;, &amp;ldquo;ls&amp;rdquo;&amp;hellip; 这样的字符串, awk只把它当成一般字符串处理.&lt;/p&gt;
&lt;p&gt;建立如下文件并取名为 reformat2.awk&lt;br&gt;
# 程序 reformat2.awk&lt;br&gt;
# 这程序用以练习awk中的pipe&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;BEGIN {  
&amp;quot;date&amp;quot; | getline # Shell 执行 &amp;quot;date&amp;quot;. getline 取得结果并以$0记录  
print &amp;quot; Today is &amp;quot; , $2, $3 &amp;gt;&amp;quot;today_rpt2&amp;quot;  
print &amp;quot;=========================&amp;quot; &amp;gt; &amp;quot;today_rpt2&amp;quot;  
print &amp;quot; ID Number Arrival Time&amp;quot; &amp;gt;&amp;quot;today_rpt2&amp;quot;  
close( &amp;quot;today_rpt2&amp;quot; )  
}  
{printf( &amp;quot;%s %s\n&amp;quot;, $1 ,$2 ) | &amp;quot;sort -k 1 &amp;gt;&amp;gt;today_rpt2&amp;quot;}  
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;today-is--09月-21日&#34;&gt;执行如下命令:&lt;br&gt;
awk -f reformat2.awk arr.dat&lt;br&gt;
执行后, 系统会自动将 sort 后的数据追加( Append; 因为使用 &amp;quot; &amp;raquo;&amp;quot;) 到文件 today_rpt2末端. today_rpt2 内容如下 :&lt;br&gt;
Today is  09月 21日&lt;/h1&gt;
&lt;p&gt;ID Number Arrival Time&lt;br&gt;
1005 8:12&lt;br&gt;
1006 7:45&lt;br&gt;
1008 8:01&lt;br&gt;
1012 7:46&lt;br&gt;
1025 7:27&lt;br&gt;
1028 7:49&lt;br&gt;
1029 7:57&lt;br&gt;
1034 7:26&lt;br&gt;
1042 7:59&lt;br&gt;
1051 7:51&lt;br&gt;
1052 8:05&lt;br&gt;
1101 7:32&lt;/p&gt;
&lt;h4 id=&#34;-说-明--&#34;&gt;[ 说 明 : ]&lt;/h4&gt;
&lt;p&gt;awk程序由三个主要部分构成 :&lt;br&gt;
[ i.] Pattern { Action} 指令&lt;br&gt;
[ ii.] 函数主体. 例如 : function double( x ){ return 2*x } (参考第11节 Recursive Program )&lt;br&gt;
[ iii.] Comment ( 以 # 开头识别之 )&lt;br&gt;
awk 的输入指令 getline, 每次读取一列数据. 若getline之后&lt;br&gt;
未接任何变量, 则所读入之资料将以$0 记录, 否则以所指定的变量储存之.&lt;/p&gt;
&lt;h4 id=&#34;-以本例而言-&#34;&gt;[ 以本例而言] :&lt;/h4&gt;
&lt;p&gt;执行 &amp;ldquo;date&amp;rdquo; | getline 后, $0 之值为 &amp;ldquo;2007年 09月 21日 星期五 14:28:02 CST&amp;rdquo;,当 $0 之值被更新时, awk将自动更新相关的内建变量, 如: $1,$2,..,NF.故 $2 之值将为&amp;quot;09月&amp;rdquo;, $3之值将为&amp;quot;21日&amp;rdquo;.&lt;br&gt;
(有少数旧版的awk不允许即使用者自行更新(update)$0的值,或者更新$0时,它不会自动更新 $1,$2,..NF. 这情况下, 可改用gawk或nawk. 否则使用者也可自行以awk字符串函数split()来分隔$0上的数据)&lt;br&gt;
本程序中 printf() 指令会被执行12次( 因为有arr.dat中有12行数据), 但读者不用担心数据被重复sort了12次. 当awk结束该程序时才会 close 这个 pipe , 此时才将这12行数据一次送往系统,并呼叫 &amp;ldquo;sort -k 1 &amp;raquo; today_rpt2&amp;rdquo; 处理之.&lt;br&gt;
awk提供另一个调用Shell命令的方法, 即使用awk函数system(&amp;ldquo;shell命令&amp;rdquo;)&lt;br&gt;
例如:&lt;br&gt;
$ awk &#39;&lt;br&gt;
BEGIN{&lt;br&gt;
system(&amp;ldquo;date &amp;gt; date.dat&amp;rdquo;)&lt;br&gt;
getline &amp;lt; &amp;ldquo;date.dat&amp;rdquo;&lt;br&gt;
print &amp;ldquo;Today is &amp;ldquo;, $2, $3&lt;br&gt;
}&lt;br&gt;
&#39;&lt;/p&gt;
&lt;p&gt;但使用 system( &amp;ldquo;shell 命令&amp;rdquo; ) 时, awk无法直接将执行中的部分数据输出给Shell 命令. 且 Shell 命令执行的结果也无法直接输入到awk中.&lt;/p&gt;
&lt;h3 id=&#34;执行-awk-程序的几种方式&#34;&gt;执行 awk 程序的几种方式&lt;/h3&gt;
&lt;p&gt;本小节中描述如何将awk程序直接写在 shell script 之中. 此后使用者执行 awk 程序时, 就不需要每次都键入 &amp;quot; awk -f program datafile&amp;rdquo; .&lt;br&gt;
script 中还可包含其它 Shell 命令, 如此更可增加执行过程的自动化.&lt;br&gt;
建立一个简单的 awk程序 mydump.awk, 如下:&lt;br&gt;
{print}&lt;br&gt;
这个程序执行时会把数据文件的内容 print 到屏幕上( 与cat功用类似 ).&lt;br&gt;
print 之后未接任何参数时, 表示 &amp;ldquo;print $0&amp;rdquo;.&lt;br&gt;
若欲执行该awk程序, 来印出文件 today_rpt1 及 today_rpt2 的内容时,&lt;br&gt;
必须于 UNIX 的命令行上执行下列命令 :&lt;br&gt;
方式一 awk -f mydump.awk today_rpt1 today_rpt2&lt;br&gt;
方式二 awk &amp;lsquo;{print}&amp;rsquo; today_rpt1 today_rpt2第二种方式系将awk 程序直接写在 Shell 的命令行上, 这种方式仅适合较短的awk程序.&lt;br&gt;
方式三 建立如下之 shell script, 并取名为 mydisplay,&lt;br&gt;
#!/bin/sh&lt;/p&gt;
&lt;p&gt;注意以下的 awk 与 &#39; 之间须有空白隔开&lt;br&gt;
awk &#39;&lt;br&gt;
{print}&lt;br&gt;
&#39; $*&lt;br&gt;
注意以上的 &#39; 与 $* 之间须有空白隔开&lt;/p&gt;
&lt;p&gt;执行 mydisplay 之前, 须先将它改成可执行的文件(此步骤往后不再赘述). 请执行如下命令:&lt;br&gt;
$ chmod +x mydisplay&lt;br&gt;
往后使用者就可直接把 mydisplay 当成指令, 来display任何文件.&lt;br&gt;
例如 :&lt;br&gt;
$ ./mydisplay today_rpt1 today_rpt2&lt;br&gt;
[ 说 明 : ]&lt;br&gt;
在script文件 mydisplay 中, 指令&amp;quot;awk&amp;quot;与第一个 &#39;  之间须有空格(Shell中并无&amp;rdquo; awk&#39; &amp;ldquo;指令).&lt;br&gt;
第一个 &#39; 用以通知 Shell 其后为awk程序.&lt;br&gt;
第二个 &#39; 则表示 awk 程序结束.&lt;br&gt;
故awk程序中一律以&amp;quot;括住字符串或字符, 而不使用 &#39; , 以免Shell混淆.&lt;br&gt;
$* 为 shell script中的用法, 它可用来代表命令行上 &amp;ldquo;mydisplay之后的所有参数&amp;rdquo;.&lt;br&gt;
例如执行 :&lt;br&gt;
$ mydisplay today_rpt1 today_rpt2&lt;br&gt;
事实上 Shell 已先把该指令转换成 :&lt;br&gt;
awk &#39;&lt;br&gt;
{ print}&lt;br&gt;
&#39; today_rpt1 today_rpt2&lt;br&gt;
本例中, $* 用以代表 &amp;ldquo;today_rpt1 today_rpt2&amp;rdquo;. 在Shell的语法中, 可用 $1 代表第一个参数, $2 代表第二个参数. 当不确定命令行上的参数个数时, 可使用 $* 表之.&lt;br&gt;
awk命令行上可同时指定多个数据文件.&lt;br&gt;
以awk -f dump.awk today_rpt1 today_rpt2hf 为例,awk会先处理today_rpt1, 再处理 today_rpt2. 此时若文件无法打开, 将造成错误.&lt;/p&gt;
&lt;p&gt;例如: 不存在文件&amp;quot;file_no_exist&amp;rdquo;, 则执行 :&lt;br&gt;
$ awk -f dump.awk file_no_exit&lt;br&gt;
将产生运行时错误(无法打开文件).&lt;br&gt;
但某些awk程序 &amp;ldquo;仅&amp;rdquo; 包含以 BEGIN 为Pattern的指令. 执行这种awk程序时, awk并不须开启任何数据文件.此时命令行上若指定一个不存在的数据文件,并不会产生 &amp;ldquo;无法打开文件&amp;quot;的错误.(事实上awk并未打开该文件)&lt;/p&gt;
&lt;p&gt;例如执行:&lt;br&gt;
$ awk &amp;lsquo;BEGIN {print &amp;ldquo;Hello,World!!&amp;quot;} &#39; file_no_exist&lt;br&gt;
该程序中仅包含以 BEGIN 为 Pattern 的 Pattern {actions}, awk 执行时并不会开启任何数据文件; 所以不会因不存在文件file_no_exit而产生 &amp;quot; 无法打开文件&amp;quot;的错误.&lt;br&gt;
awk会将 Shell 命令行上awk程序(或 -f 程序文件名)之后的所有字符串, 视为将输入awk进行处理的数据文件文件名.&lt;/p&gt;
&lt;p&gt;若执行awk的命令行上 &amp;ldquo;未指定任何数据文件文件名&amp;rdquo;, 则将stdin视为输入之数据来源, 直到输入end of file( Ctrl-D )为止.&lt;br&gt;
读者可以用下列程序自行测试, 执行如下命令 :&lt;br&gt;
$ awk -f mydump.awk  #(未接任何数据文件文件名)&lt;br&gt;
或&lt;br&gt;
$ ./mydisplay  #(未接任何数据文件文件名)&lt;/p&gt;
&lt;p&gt;将会发现: 此后键入的任何数据将逐行复印一份于屏幕上. 这情况不是机器当机 ! 是因为awk程序正处于执行中. 它正按程序指示, 将读取数据并重新dump一次; 只因执行时未指定数据文件文件名, 故awk 便以stdin(键盘上的输入)为数据来源. 读者可利用这个特点, 设计可与awk即时聊天的程序.&lt;/p&gt;
&lt;h3 id=&#34;改变-awk-切割字段的方式--自定义函数&#34;&gt;改变 awk 切割字段的方式 &amp;amp; 自定义函数&lt;/h3&gt;
&lt;p&gt;awk不仅能自动分割字段, 也允许使用者改变其字段切割方式以适应各种格式之需要. 使用者也可自定义函数, 若有需要可将该函数单独写成一个文件,以供其它awk程序调用.&lt;/p&gt;
&lt;h4 id=&#34;-范例--&#34;&gt;[ 范例 : ]&lt;/h4&gt;
&lt;p&gt;承接 6.2 的例子, 若八点为上班时间, 请加注 &amp;ldquo;*&amp;ldquo;于迟到记录之前, 并计算平均上班时间.&lt;/p&gt;
&lt;h4 id=&#34;-分-析-&#34;&gt;[ 分 析: ]&lt;/h4&gt;
&lt;p&gt;因八点整到达者,不为迟到, 故仅以到达的小时数做判断是不够的; 仍应参考到达时的分钟数. 若 &amp;ldquo;将到达时间转换成以分钟为单位&amp;rdquo;, 不仅易于判断是否迟到, 同时也易于计算到达平均时间.&lt;br&gt;
到达时间($2)的格式为 dd:dd 或 d:dd; 数字当中含有一个 &amp;ldquo;:&amp;quot;.但文本数字交杂的数据awk无法直接做数学运算. (注: awk中字符串&amp;quot;26&amp;quot;与数字26, 并无差异, 可直接做字符串或数学运算,这是awk重要特色之一. 但awk对文本数字交杂的字符串无法正确进行数学运算).&lt;/p&gt;
&lt;h4 id=&#34;解决之方法-&#34;&gt;解决之方法 :&lt;/h4&gt;
&lt;h5 id=&#34;方法一&#34;&gt;[方法一]&lt;/h5&gt;
&lt;p&gt;对到达时间($2) d:dd 或 dd:dd 进行字符串运算,分别取出到达的小时数及分钟数.&lt;/p&gt;
&lt;p&gt;首先判断到达小时数为一位或两位字符,再调用函数分别截取分钟数及小时数.&lt;br&gt;
此解法需使用下列awk字符串函数:&lt;br&gt;
length( 字符串 ) : 返回该字符串的长度.&lt;br&gt;
substr( 字符串,起始位置,长度) :返回从起始位置起, 指定长度之子字符串. 若未指定长度, 则返回从起始位置到字符串末尾的子字符串.&lt;br&gt;
所以:&lt;br&gt;
小时数 = substr( $2, 1, length($2) - 3 )&lt;br&gt;
分钟数 = substr( $2, length($2) - 2 )&lt;/p&gt;
&lt;h5 id=&#34;方法二&#34;&gt;[方法二]&lt;/h5&gt;
&lt;p&gt;改变输入列字段的切割方式, 使awk切割字段后分别将小时数及分钟数隔开于二个不同的字段.&lt;br&gt;
字段分隔字符 FS (field seperator) 是awk的内建变量,其默认值是空白及tab. awk每次切割字段时都会先参考FS 的内容. 若把&amp;rdquo;:&amp;ldquo;也当成分隔字符, 则awk 便能自动把小时数及分钟数分隔成不同的字段.故令FS = &amp;ldquo;[ \t:]+&amp;rdquo; (注: [ \t:]+ 为一Regular Expression )&lt;br&gt;
Regular Expression 中使用中括号 [ &amp;hellip; ] 表示一个字符集合,用以表示任意一个位于两中括号间的字符.故可用&amp;rdquo;[ \t:]&amp;ldquo;表示 一个 空白 , tab 或 &amp;ldquo;:&amp;rdquo;&lt;br&gt;
Regular Expression中使用 &amp;ldquo;+&amp;rdquo; 形容其前方的字符可出现一次&lt;br&gt;
或一次以上.&lt;br&gt;
故 &amp;ldquo;[ \t:]+&amp;rdquo; 表示由一个或多个 &amp;ldquo;空白, tab 或 : &amp;quot; 所组成的字符串.&lt;br&gt;
设定 FS =&amp;quot;[ \t:]+&amp;rdquo; 后, 数据行如: &amp;ldquo;1034 7:26&amp;rdquo; 将被分割成3个字段&lt;br&gt;
第一栏 第二栏 第三栏&lt;br&gt;
$1 $2 $3&lt;br&gt;
1034 7 26&lt;br&gt;
明显地, awk程序中使用方法二比方法一更简洁方便. 本例子中采用方法二,也借此示范改变字段切割方式的用途.&lt;br&gt;
编写awk程序 reformat3, 如下 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/sh  
   
awk &#39;  
BEGIN {  
FS= &amp;quot;[ \t:]+&amp;quot; #改变字段切割的方式  
&amp;quot;date&amp;quot; | getline # Shell 执行 &amp;quot;date&amp;quot;. getline 取得结果以$0记录  
print &amp;quot; Today is &amp;quot; ,$2, $3 &amp;gt; &amp;quot;today_rpt3&amp;quot;  
print &amp;quot;=========================&amp;quot;&amp;gt;&amp;quot;today_rpt3&amp;quot;  
print &amp;quot; ID Number Arrival Time&amp;quot; &amp;gt; &amp;quot;today_rpt3&amp;quot;  
close( &amp;quot;today_rpt3&amp;quot; )  
}  
{  
#已更改字段切割方式, $2表到达小时数, $3表分钟数  
arrival = HM_to_M($2, $3)  
printf(&amp;quot; %s %s:%s %s\n&amp;quot;, $1, $2, $3, arrival &amp;gt; 480 ? &amp;quot;*&amp;quot;: &amp;quot; &amp;quot; ) | &amp;quot;sort -k 1 &amp;gt;&amp;gt; today_rpt3&amp;quot;  
total += arrival  
}  
END {  
close(&amp;quot;today_rpt3&amp;quot;)  
close(&amp;quot;sort -k 1 &amp;gt;&amp;gt; today_rpt3&amp;quot;)  
printf(&amp;quot; Average arrival time : %d:%d\n&amp;quot;,total/NR/60, (total/NR)%60 ) &amp;gt;&amp;gt; &amp;quot;today_rpt3&amp;quot;  
}  
function HM_to_M( hour, min ){  
return hour*60 + min  
}  
&#39; $*  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;并执行如下指令:&lt;br&gt;
$ ./reformat3 arr.dat&lt;br&gt;
执行后,文件 today_rpt3 的内容如下:&lt;br&gt;
Today is  09月 21日&lt;/p&gt;
&lt;p&gt;=========================&lt;br&gt;
ID Number Arrival Time&lt;br&gt;
1005 8:12 *&lt;br&gt;
1006 7:45&lt;br&gt;
1008 8:01 *&lt;br&gt;
1012 7:46&lt;br&gt;
1025 7:27&lt;br&gt;
1028 7:49&lt;br&gt;
1029 7:57&lt;br&gt;
1034 7:26&lt;br&gt;
1042 7:59&lt;br&gt;
1051 7:51&lt;br&gt;
1052 8:05 *&lt;br&gt;
1101 7:32&lt;br&gt;
Average arrival time : 7:49&lt;/p&gt;
&lt;h4 id=&#34;-说-明---1&#34;&gt;[ 说 明 : ]&lt;/h4&gt;
&lt;p&gt;awk 中亦允许使用者自定函数. 函数定义方式请参考本程序, function 为 awk 的保留字.&lt;br&gt;
HM_to_M( ) 这函数负责将所传入之小时及分钟数转换成以分钟为单位. 使用者自定函数时, 还有许多细节须留心, 如data scope,.. ( 请参考 第十节 Recursive Program)&lt;/p&gt;
&lt;p&gt;awk中亦提供与 C 语言中相同的 Conditional Operator. 上式printf()中使用arrival &amp;gt;480 ? &amp;ldquo;&lt;em&gt;&amp;rdquo; : &amp;quot; &amp;quot; 即为一例若 arrival 大于 480 则return &amp;ldquo;&lt;/em&gt;&amp;rdquo; , 否则return &amp;quot; &amp;ldquo;.&lt;/p&gt;
&lt;p&gt;% 为awk的运算符(operator), 其作用与 C 语言中之 % 相同(取余数).&lt;br&gt;
NR(Number of Record) 为awk的内建变量. 表示awk执行该程序后所读入的记录笔数.&lt;/p&gt;
&lt;p&gt;awk 中提供的 close( )指令, 语法如下(有二种) :&lt;br&gt;
close( filename )&lt;br&gt;
close( 置于pipe之前的command )&lt;br&gt;
为何本程序使用了两个 close( ) 指令 :&lt;br&gt;
指令 close( &amp;ldquo;sort -k 1 &amp;raquo; today_rpt3&amp;rdquo; ), 其意思为 close 程序中置于 &amp;ldquo;sort -k 1 &amp;raquo; today_rpt3 &amp;quot; 之前的 Pipe , 并立刻调用 Shell 来执行&amp;quot;sort -k 1 &amp;raquo; today_rpt3&amp;rdquo;. (若未执行这指令, awk必须于结束该程序时才会进行上述动作;则这12笔sort后的数据将被 append 到文件 today_rpt3 中&lt;br&gt;
&amp;ldquo;Average arrival time : &amp;hellip;&amp;rdquo; 的后方)&lt;br&gt;
因为 Shell 排序后的数据也要写到 today_rpt3, 所以awk必须先关闭使用中的today_rpt3 以使 Shell 正确将排序后的数据追加到today_rpt3否则2个不同的 process 同时打开一个文件进行输出将会产生不可预期的结果.&lt;br&gt;
读者应留心上述两点,才可正确控制数据输出到文件中的顺序.&lt;br&gt;
指令 close(&amp;ldquo;sort -k 1 &amp;raquo; today_rpt3&amp;rdquo;)中字符串 &amp;ldquo;sort -k 1 &amp;raquo; today_rpt3&amp;rdquo; 必须与 pipe | 后方的 Shell Command 名称一字不差, 否则awk将视为二个不同的 pipe.&lt;br&gt;
读者可于BEGIN{}中先令变量 Sys_call = &amp;ldquo;sort -k 1 &amp;raquo; today_rpt3&amp;rdquo;,&lt;br&gt;
程序中再一律以 Sys_call 代替该字符串.&lt;/p&gt;
&lt;h3 id=&#34;使用-getline-来读取数据&#34;&gt;使用 getline 来读取数据&lt;/h3&gt;
&lt;p&gt;[ 范 例 : ] 承上题,从文件中读取当月迟到次数, 并根据当日出勤状况更新迟到累计数.(按不同的月份累计于不同的文件)&lt;br&gt;
[ 分 析 : ]&lt;br&gt;
程序中自动抓取系统日期的月份名称, 连接上&amp;quot;late.dat&amp;rdquo;, 形成累计迟到次数的文件名称(如 : 09月late.dat,&amp;hellip;), 并以变量late_file记录该文件名.&lt;br&gt;
累计迟到次数的文件中的数据格式为: 员工代号(ID) 迟到次数&lt;br&gt;
例如, 执行本程序前文件 09月late.dat 的内容为 :&lt;br&gt;
1012 0&lt;br&gt;
1006 1&lt;br&gt;
1052 2&lt;br&gt;
1034 0&lt;br&gt;
1005 0&lt;br&gt;
1029 2&lt;br&gt;
1042 0&lt;br&gt;
1051 0&lt;br&gt;
1008 0&lt;br&gt;
1101 0&lt;br&gt;
1025 1&lt;br&gt;
1028 0&lt;/p&gt;
&lt;p&gt;编写程序 reformat4 如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/sh  
   
awk &#39;  
BEGIN {  
Sys_Sort = &amp;quot;sort -k 1 &amp;gt;&amp;gt; today_rpt4&amp;quot;  
Result = &amp;quot;today_rpt4&amp;quot;  
# 改变字段切割的方式  
FS = &amp;quot;[ \t:]+&amp;quot;  
# 令 Shell执行&amp;quot;date&amp;quot;; getline 读取结果,并以$0记录  
&amp;quot;date&amp;quot; | getline  
print &amp;quot; Today is &amp;quot; , $2, $3 &amp;gt;Result  
print &amp;quot;=========================&amp;quot; &amp;gt; Result  
print &amp;quot; ID Number Arrival Time&amp;quot; &amp;gt; Result  
close( Result )  
# 从文件按中读取迟到数据, 并用数组cnt[ ]记录. 数组cnt[ ]中以  
# 员工代号为下标, 所对应的值为该员工之迟到次数.  
late_file = $2&amp;quot;late.dat&amp;quot;  
while( getline &amp;lt; late_file &amp;gt;0 ) cnt[$1] = $2  
close( late_file )  
}  
{  
# 已更改字段切割方式, $2表小时数,$3表分钟数  
arrival = HM_to_M($2, $3)  
if( arrival &amp;gt; 480 ){  
mark = &amp;quot;*&amp;quot; # 若当天迟到,应再增加其迟到次数, 且令mark 为&amp;quot;*&amp;quot;.  
cnt[$1]++ }  
else mark = &amp;quot; &amp;quot;  
   
# message 用以显示该员工的迟到累计数, 若未曾迟到message为空字符串  
message = cnt[$1] ? cnt[$1] &amp;quot; times&amp;quot; : &amp;quot;&amp;quot;  
printf(&amp;quot;%s %2d:%2d %5s %s\n&amp;quot;, $1, $2, $3, mark, message ) | Sys_Sort  
total += arrival  
}  
END {  
close( Result )  
close( Sys_Sort )  
printf(&amp;quot; Average arrival time : %d:%d\n&amp;quot;, total/NR/60, (total/NR)%60 ) &amp;gt;&amp;gt; Result  
#将数组cnt[ ]中新的迟到数据写回文件中  
for( any in cnt )  
print any, cnt[any] &amp;gt; late_file  
}  
function HM_to_M( hour, min ){  
return hour*60 + min  
}  
&#39; $*  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行后, today_rpt4 之内容如下 :&lt;br&gt;
Today is  09月 21日&lt;/p&gt;
&lt;p&gt;=========================&lt;br&gt;
ID Number Arrival Time&lt;br&gt;
1005  8:12     * 1 times&lt;br&gt;
1006  7:45       1 times&lt;br&gt;
1008  8: 1     * 1 times&lt;br&gt;
1012  7:46     &lt;br&gt;
1025  7:27       1 times&lt;br&gt;
1028  7:49     &lt;br&gt;
1029  7:57       2 times&lt;br&gt;
1034  7:26     &lt;br&gt;
1042  7:59     &lt;br&gt;
1051  7:51     &lt;br&gt;
1052  8: 5     * 3 times&lt;br&gt;
1101  7:32     &lt;br&gt;
Average arrival time : 7:49&lt;br&gt;
09月late.dat 文件被修改为如下:&lt;br&gt;
1005 1&lt;br&gt;
1012 0&lt;br&gt;
1006 1&lt;br&gt;
1008 1&lt;br&gt;
1101 0&lt;br&gt;
1025 1&lt;br&gt;
1034 0&lt;br&gt;
1042 0&lt;br&gt;
1028 0&lt;br&gt;
1029 2&lt;br&gt;
1051 0&lt;br&gt;
1052 3&lt;/p&gt;
&lt;h4 id=&#34;说-明-&#34;&gt;说 明 :&lt;/h4&gt;
&lt;p&gt;late_file 是一变量, 用以记录迟到次数的文件的文件名.&lt;br&gt;
late_file之值由两部分构成, 前半部是当月月份名称(由调用&amp;quot;date&amp;quot;取得)后半部固定为&amp;quot;late.dat&amp;rdquo; 如: 09月late.dat.&lt;br&gt;
指令 getline &amp;lt; late_file 表示从late_file所代表的文件中读取一笔记录, 并存放于$0.&lt;br&gt;
若使用者可自行把数据放入$0, awk会自动对这新置入 $0 的数据进行字段分割. 之后程序中可用$1, $2,..来表示该笔资料的第一栏,第二栏,..,&lt;br&gt;
(注: 有少数awk版本不容许使用者自行将数据置于 $0, 遇此情况可改用gawk或nawk)&lt;br&gt;
执行getline指令时, 若成功读取记录,它会返回1. 若遇到文件结束, 它返回0; 无法打开文件则返回-1.&lt;br&gt;
利用 while( getline &amp;lt; filename &amp;gt;0 ) {&amp;hellip;.}可读入文件中的每一笔数据并予处理. 这是awk中用户自行读取数据文件的一个重要模式.&lt;br&gt;
数组 cnt[ ] 以员工ID. 当下标(index), 其对应值表示其迟到的次数.&lt;br&gt;
执行结束后, 利用 for(Variable in array ){&amp;hellip;}的语法&lt;br&gt;
for( any in cnt ) print any, cnt[any] &amp;gt; late_file&lt;br&gt;
将更新过的迟到数据重新写回记录迟到次数的文件. 该语法在前面曾有说明.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>8. 处理多行的数据</title>
      <link>https://wukong.tongji.edu.cn/internal/zhuqianshu.awk-best-manual/8/</link>
      <pubDate>Mon, 21 Dec 2020 00:00:00 +0000</pubDate>
      <guid>https://wukong.tongji.edu.cn/internal/zhuqianshu.awk-best-manual/8/</guid>
      <description>&lt;p&gt;awk 每次从数据文件中只读取一数据进行处理.&lt;br&gt;
awk是依照其内建变量 RS(Record Separator) 的定义将文件中的数据分隔成一行一行的Record. RS 的默认值是 &amp;ldquo;\n&amp;rdquo;(跳行符号), 故平常awk中一行数据就是一笔 Record. 但有些文件中一笔Record涵盖了多行数据, 这种情况下不能再以 &amp;ldquo;\n&amp;rdquo; 来分隔Records. 最常使用的方法是相邻的Records之间改以 一个空白行 来隔开. 在awk程序中, 令 RS = &amp;ldquo;&amp;quot;(空字符串)后, awk把会空白行当成来文件中Record的分隔符. 显然awk对 RS = &amp;quot;&amp;rdquo; 另有解释方式,简略描述如下, 当 RS = &amp;quot;&amp;quot; 时:数个并邻的空白行, awk仅视成一个单一的Record Saparator. (awk不会于两个紧并的空白行之间读取一笔空的Record)&lt;br&gt;
awk会略过(skip)文件头或文件尾的空白行. 故不会因为这样的空白行,造成awk多读入了二笔空的数据.&lt;br&gt;
请观察下例,首先建立一个数据文件 week.rpt如下:&lt;/p&gt;
&lt;p&gt;张长弓&lt;br&gt;
GNUPLOT 入门&lt;/p&gt;
&lt;p&gt;吴国强&lt;br&gt;
Latex 简介&lt;br&gt;
VAST-2 使用手册&lt;br&gt;
mathematic 入门&lt;/p&gt;
&lt;p&gt;李小华&lt;br&gt;
awk Tutorial Guide&lt;br&gt;
Regular Expression&lt;/p&gt;
&lt;p&gt;该文件的开头有数行空白行, 各笔Record之间使用一个或数个空白行隔开. 读者请细心观察,当 RS = &amp;quot;&amp;quot; 时, awk读取该数据文件之方式.&lt;br&gt;
编辑一个awk程序文件 make_report如下:&lt;br&gt;
#!/bin/sh&lt;/p&gt;
&lt;p&gt;awk &#39;&lt;br&gt;
BEGIN {&lt;br&gt;
FS = &amp;ldquo;\n&amp;rdquo;&lt;br&gt;
RS = &amp;quot;&amp;quot;&lt;br&gt;
split( &amp;ldquo;一. 二. 三. 四. 五. 六. 七. 八. 九.&amp;rdquo;, C_Number, &amp;quot; &amp;quot; )&lt;br&gt;
}&lt;br&gt;
{&lt;br&gt;
printf(&amp;quot;\n%s 报告人 : %s \n&amp;quot;,C_Number[NR],$1)&lt;br&gt;
for( i=2; i &amp;lt;= NF; i++) printf(&amp;quot; %d. %s\n&amp;quot;, i-1, $i)&lt;br&gt;
} &#39; $*&lt;br&gt;
执行&lt;br&gt;
$ make_report week.rpt&lt;br&gt;
屏幕产生结果如下:&lt;/p&gt;
&lt;p&gt;一. 报告人 : 张长弓&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;GNUPLOT 入门&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;二. 报告人 : 吴国强&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Latex 简介&lt;/li&gt;
&lt;li&gt;VAST-2 使用手册&lt;/li&gt;
&lt;li&gt;mathematic 入门&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;三. 报告人 : 李小华&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;awk Tutorial Guide&lt;/li&gt;
&lt;li&gt;Regular Expression&lt;br&gt;
[ 说 明: ]&lt;br&gt;
本程序同时也改变字段分隔字符( FS= &amp;ldquo;\n&amp;rdquo; ), 如此一笔数据中的每一行都是一个field. 例如: awk读入的第一笔 Record 为&lt;br&gt;
张长弓&lt;br&gt;
GNUPLOT 入门&lt;br&gt;
其中 $1 指的是&amp;quot;张长弓&amp;quot;, $2 指的是&amp;quot;GNUPLOT 入门&amp;quot;&lt;br&gt;
上式中的C_Number&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 是一个数组(array), 用以记录中文数字. 例如: C_Number[1] = &amp;ldquo;一.&amp;rdquo;, C_Number[2] = &amp;ldquo;二.&amp;rdquo; 这过程使用awk字符串函数 split( ) 来把中文数字放进数组C_Number&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 中.&lt;br&gt;
函数 split( )用法如下:&lt;br&gt;
split( 原字符串, 数组名, 分隔字符(field separator) ) : awk将依所指定的分隔字符(field separator)分隔原字符串成一个个的字段(field), 并以指定的 数组 记录各个被分隔的字段&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>9. 如何读取命令行上的参数 </title>
      <link>https://wukong.tongji.edu.cn/internal/zhuqianshu.awk-best-manual/9/</link>
      <pubDate>Mon, 21 Dec 2020 00:00:00 +0000</pubDate>
      <guid>https://wukong.tongji.edu.cn/internal/zhuqianshu.awk-best-manual/9/</guid>
      <description>&lt;p&gt;大部分的应用程序都允许使用者在命令之后增加一些选择性的参数.执行awk时这些参数大部分用于指定数据文件文件名, 有时希望在程序中能从命令行上得到一些其它用途的数据. 本小节中将叙述如何在awk程序中取用这些参数.&lt;br&gt;
建立文件如下, 命名为 see_arg :&lt;br&gt;
#!/bin/sh&lt;/p&gt;
&lt;p&gt;awk &#39;&lt;br&gt;
BEGIN {&lt;br&gt;
for( i=0; i&amp;lt;ARGC ; i++)&lt;br&gt;
print ARGV[i] # 依次印出awk所记录的参数&lt;br&gt;
}&lt;br&gt;
&#39; $*&lt;br&gt;
执行如下命令 :&lt;br&gt;
$ ./see_arg first-arg second-arg&lt;br&gt;
结果屏幕出现 :&lt;br&gt;
awk&lt;br&gt;
first-arg&lt;br&gt;
second-arg&lt;br&gt;
[ 说明 : ]&lt;br&gt;
ARGC, ARGV[ ] 为awk所提供的内建变量.&lt;/p&gt;
&lt;p&gt;ARGC : 为一整数. 代表命令行上, 除了选项-v, -f 及其对应的参数之外所有参数的数目.&lt;br&gt;
ARGV[ ] : 为一字符串数组. ARGV[0],ARGV[1],&amp;hellip;ARGV[ARGC-1].&lt;br&gt;
分别代表命令行上相对应的参数.&lt;/p&gt;
&lt;p&gt;例如, 当命令行为 :&lt;br&gt;
$ awk -vx=36 -f program1 data1 data2&lt;br&gt;
或&lt;br&gt;
$ awk &amp;lsquo;{ print $1 ,$2 }&amp;rsquo; data1 data2&lt;br&gt;
其 ARGC 之值为 3&lt;br&gt;
ARGV[0] 之值为 &amp;ldquo;awk&amp;rdquo;&lt;br&gt;
ARGV[1] 之值为 &amp;ldquo;data1&amp;rdquo;&lt;br&gt;
ARGV[2] 之值为 &amp;ldquo;data2&amp;rdquo;&lt;br&gt;
命令行上的 &amp;ldquo;-f program1&amp;rdquo;, &amp;quot; -vx=36&amp;quot;, 或程序部分 &amp;lsquo;{ print $1, $2}&amp;rsquo; 都不会列入 ARGC 及 ARGV[ ] 中.&lt;br&gt;
awk 利用 ARGC 来判断应开启的数据文件个数.&lt;br&gt;
但使用者可强行改变 ARGC; 当 ARGC 之值被使用者设为 1 时;&lt;br&gt;
awk将被蒙骗,误以为命令行上并无数据文件文件名, 故不会以 ARGV[1], ARGV[2],..为文件名来打开文件读取数据; 但在程序中仍可通过 ARGV[1], ARGV[2],..来取得命令行上的数据.&lt;/p&gt;
&lt;p&gt;某一程序 test1.awk 如下 :&lt;br&gt;
BEGIN{&lt;br&gt;
number = ARGC #先用number 记住实际的参数个数.&lt;br&gt;
ARGC = 2 # 自行更改 ARGC=2, awk将以为只有一个资料文件&lt;br&gt;
# 仍可藉由ARGV[ ]取得命令行上的资料.&lt;br&gt;
for( i=2; i&amp;lt;number; i++) data[i] = ARGV[i]&lt;br&gt;
}&lt;br&gt;
&amp;hellip;&amp;hellip;..&lt;br&gt;
于命令行上键入&lt;br&gt;
$ awk -f test1.awk data_file apple orange&lt;br&gt;
执行时 awk 会打开数据文件 data_file 以进行处理. 但不会打开以apple,orange 为档名的文件(因为 ARGC 被改成2). 但仍可通过ARGV[2], ARGV[3]取得命令行上的参数 apple, orange&lt;/p&gt;
&lt;p&gt;也可以用下列命令来达成上例的效果.&lt;br&gt;
$awk -f test2.awk -v data[2]=&amp;ldquo;apple&amp;rdquo; -v data[3]=&amp;ldquo;orange&amp;rdquo; data_file&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>10.编写可与用户交互的 awk 程序 </title>
      <link>https://wukong.tongji.edu.cn/internal/zhuqianshu.awk-best-manual/10/</link>
      <pubDate>Mon, 21 Dec 2020 00:00:00 +0000</pubDate>
      <guid>https://wukong.tongji.edu.cn/internal/zhuqianshu.awk-best-manual/10/</guid>
      <description>&lt;p&gt;执行awk程序时, awk会自动从文件中读取数据来进行处理, 直到文件结束.只要将awk读取数据的来源改成键盘输入,便可设计与awk 交互的程序了.&lt;br&gt;
本节将提供一个该类程序的范例.&lt;/p&gt;
&lt;h4 id=&#34;-范例-&#34;&gt;[ 范例 :]&lt;/h4&gt;
&lt;p&gt;本节将编写一个英语生字测验的程序, 它将印出中文字意,再由使用者回答其英语生字.&lt;br&gt;
首先编辑一个数据挡 test.dat (内容不限,格式如下)&lt;br&gt;
apple 苹果&lt;br&gt;
orange 柳橙&lt;br&gt;
banana 香蕉&lt;br&gt;
pear 梨子&lt;br&gt;
starfruit 杨桃&lt;br&gt;
bellfruit 莲雾&lt;br&gt;
kiwi 奇异果&lt;br&gt;
pineapple 菠萝&lt;br&gt;
watermelon 西瓜&lt;/p&gt;
&lt;p&gt;编辑awk程序&amp;quot;c2e&amp;quot;如下:&lt;br&gt;
#!/bin/sh&lt;/p&gt;
&lt;p&gt;awk &#39;&lt;br&gt;
BEGIN {&lt;br&gt;
while( getline &amp;lt; ARGV[1] ){ #由指定的文件中读取测验数据&lt;br&gt;
English[++n] = $1 # 最后, n 将表示题目之题数&lt;br&gt;
Chinese[n] = $2&lt;br&gt;
}&lt;br&gt;
ARGV[1] = &amp;ldquo;-&amp;rdquo; # &amp;ldquo;-&amp;ldquo;表示由stdin(键盘输入)&lt;br&gt;
srand() # 以系统时间为随机数启始的种子&lt;br&gt;
question() #产生考题&lt;br&gt;
}&lt;/p&gt;
&lt;p&gt;{# awk自动读入由键盘上输入的数据(使用者回答的答案)&lt;br&gt;
if($1 != English[ind] )&lt;br&gt;
print &amp;ldquo;Try again!&amp;rdquo;&lt;br&gt;
else{&lt;br&gt;
print &amp;ldquo;\nYou are right !! Press Enter to Continue &amp;mdash; &amp;quot;&lt;br&gt;
getline&lt;br&gt;
question()#产生考题&lt;br&gt;
}&lt;br&gt;
}&lt;br&gt;
function question(){&lt;br&gt;
ind = int(rand()* n) + 1 #以随机数选取考题&lt;br&gt;
system(&amp;ldquo;clear&amp;rdquo;)&lt;br&gt;
print &amp;quot; Press &amp;quot;ctrl-d&amp;quot; to exit&amp;rdquo;&lt;br&gt;
printf(&amp;quot;\n%s &amp;ldquo;, Chinese[ind] &amp;quot; 的英文生字是: &amp;ldquo;)&lt;br&gt;
}&lt;br&gt;
&#39; $*&lt;br&gt;
执行时键入如下指令 :&lt;br&gt;
$./c2e test.dat&lt;br&gt;
屏幕将产生如下的画面:&lt;br&gt;
Press &amp;ldquo;ctrl-d &amp;quot; to exit&lt;/p&gt;
&lt;p&gt;莲雾 的英文生字是:&lt;br&gt;
若输入 bellfruit&lt;br&gt;
程序将产生&lt;br&gt;
You are right !! Press Enter to Continue &amp;mdash;&lt;/p&gt;
&lt;h4 id=&#34;-说-明--&#34;&gt;[ 说 明 : ]&lt;/h4&gt;
&lt;p&gt;参数 test.dat (ARGV[1]) 表示储存考题的数据文件文件名. awk 由该文件上取得考题资料后, 将 ARGV[1] 改成 &amp;ldquo;-&amp;rdquo;.&lt;br&gt;
&amp;ldquo;-&amp;rdquo; 表示由 stdin(键盘输入) 数据. 键盘输入数据的结束符号 (End of file)是 ctrl-d. 当 awk 读到 ctrl-d 时就停止由 stdin 读取数据.&lt;br&gt;
awk的数学函数中提供两个与随机数有关的函数.&lt;br&gt;
srand( ) :  以当前的系统时间作为随机数的种子&lt;br&gt;
rand( ) : 返回介于 0与1之间的(近似)随机数值.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>11.使用 awk 编写递归程序</title>
      <link>https://wukong.tongji.edu.cn/internal/zhuqianshu.awk-best-manual/11/</link>
      <pubDate>Mon, 21 Dec 2020 00:00:00 +0000</pubDate>
      <guid>https://wukong.tongji.edu.cn/internal/zhuqianshu.awk-best-manual/11/</guid>
      <description>&lt;p&gt;awk 中除了函数的参数列(Argument List)上的参数(Arguments)外,所有变量不管于何处出现,全被视为全局变量. 其生命持续至程序结束 &amp;mdash; 该变量不论在function外或 function内皆可使用,只要变量名称相同所使用的就是同一个变量,直到程序结束.&lt;br&gt;
因递归函数内部的变量, 会因它调用子函数(本身)而重复使用,故编写该类函数时, 应特别留心.&lt;/p&gt;
&lt;h4 id=&#34;-例如--&#34;&gt;[ 例如 : ]&lt;/h4&gt;
&lt;p&gt;执行&lt;br&gt;
awk &#39;&lt;br&gt;
BEGIN {&lt;br&gt;
x = 35&lt;br&gt;
y = 45&lt;br&gt;
test_variable( x )&lt;br&gt;
printf(&amp;ldquo;Return to main : arg1= %d, x= %d, y= %d, z= %d\n&amp;rdquo;, arg1, x, y, z)&lt;br&gt;
}&lt;br&gt;
function test_variable( arg1 )&lt;br&gt;
{&lt;br&gt;
arg1++ # arg1 为参数列上的参数, 是local variable. 离开此函数后将消失.&lt;br&gt;
y ++ # 会改变主式中的变量 y&lt;br&gt;
z = 55 # z 为该函数中新使用的变量, 主程序中变量 z 仍可被使用.&lt;br&gt;
printf(&amp;ldquo;Inside the function: arg1=%d,x=%d, y=%d, z=%d\n&amp;rdquo;, arg1, x, y, z)&lt;br&gt;
} &#39;&lt;br&gt;
结果屏幕印出&lt;br&gt;
Inside the function: arg1=36,x=35, y=46, z=55&lt;br&gt;
Return to main : arg1= 0, x= 35, y= 46, z= 55&lt;br&gt;
由上可知 :&lt;br&gt;
函数内可任意使用主程序中的任何变量.函数内所启用的任何变量(除参数外), 于该函数之外依然可以使用.此特性优劣参半, 最大的坏处是式中的变量不易被保护, 特别是递归调用本身, 执行子函数时会破坏父函数内的变量.&lt;br&gt;
一个变通的方法是: 在函数的参数列中虚列一些参数. 函数执行中使用这些虚列的参数来记录不想被破坏的数据,如此执行子函数时就不会破坏到这些数据. 此外awk 并不会检查调用函数时所传递的参数个数是否一致.&lt;/p&gt;
&lt;h4 id=&#34;例如-&#34;&gt;例如 :&lt;/h4&gt;
&lt;p&gt;定义递归函数如下 :&lt;br&gt;
function demo( arg1 ) { # 最常见的错误例子&lt;br&gt;
&amp;hellip;&amp;hellip;..&lt;br&gt;
for(i=1; i&amp;lt; 20 ; i++){&lt;br&gt;
demo(x)&lt;/p&gt;
&lt;h1 id=&#34;又呼叫本身-因为-i-是-global-variable-故执行完该子函数后&#34;&gt;又呼叫本身. 因为 i 是 global variable, 故执行完该子函数后&lt;/h1&gt;
&lt;h1 id=&#34;原函数中的-i-已经被坏-故本函数无法正确执行&#34;&gt;原函数中的 i 已经被坏, 故本函数无法正确执行.&lt;/h1&gt;
&lt;p&gt;&amp;hellip;&amp;hellip;.&lt;br&gt;
}&lt;br&gt;
&amp;hellip;&amp;hellip;&amp;hellip;.&lt;br&gt;
}&lt;br&gt;
可将上列函数中的 i 虚列在该函数的参数列上, 如此 i 便是一个局部变量, 不会因执行子函数而被破坏.&lt;br&gt;
将上列函数修改如下:&lt;br&gt;
function demo( arg1, i )&lt;br&gt;
{&lt;br&gt;
&amp;hellip;&amp;hellip;&lt;br&gt;
for(i=1; i&amp;lt; 20; i++)&lt;br&gt;
{&lt;br&gt;
demo(x)#awk不会检查呼叫函数时, 所传递的参数个数是否一致&lt;br&gt;
&amp;hellip;..&lt;br&gt;
}&lt;br&gt;
}&lt;br&gt;
$0, $1,.., NF, NR,..也都是 global variable, 读者于递归函数中若有使用这些内建变量, 也应另外设立一些局部变量来保存,以免被破坏.&lt;/p&gt;
&lt;h4 id=&#34;-范例-&#34;&gt;[ 范例 :]&lt;/h4&gt;
&lt;p&gt;以下是一个常见的递归调用范例. 它要求使用者输入一串元素(各元素间用空白隔开) 然后印出这些元素所有可能的排列.&lt;br&gt;
编辑如下的awk式, 取名为 permu&lt;br&gt;
#!/bin/sh&lt;/p&gt;
&lt;p&gt;awk &#39;&lt;br&gt;
BEGIN {&lt;br&gt;
print &amp;ldquo;请输入排列的元素,各元素间请用空白隔开&amp;rdquo;&lt;br&gt;
getline&lt;br&gt;
permutation($0, &amp;ldquo;&amp;quot;)&lt;br&gt;
printf(&amp;quot;\n共 %d 种排列方式\n&amp;rdquo;, counter)&lt;br&gt;
}&lt;br&gt;
function permutation( main_lst, buffer,     new_main_lst, nf, i, j )&lt;br&gt;
{&lt;br&gt;
$0 = main_lst # 把main_lst指定给$0之后awk将自动进行字段分割.&lt;br&gt;
nf = NF # 故可用 NF 表示 main_lst 上存在的元素个数.&lt;br&gt;
# BASE CASE : 当main_lst只有一个元素时.&lt;br&gt;
if( nf == 1){&lt;br&gt;
print buffer main_lst #buffer的内容再加上main_lst就是完成一次排列的结果&lt;br&gt;
counter++&lt;br&gt;
return&lt;br&gt;
}&lt;br&gt;
# General Case : 每次从 main_lst 中取出一个元素放到buffer中&lt;br&gt;
# 再用 main_lst 中剩下的元素 (new_main_lst) 往下进行排列&lt;br&gt;
else for( i=1; i&amp;lt;=nf ;i++)&lt;br&gt;
{&lt;br&gt;
$0 = main_lst # $0为全局变量已被破坏, 故重新把main_lst赋给$0,令awk再做一次字段分割&lt;br&gt;
new_main_lst = &amp;quot;&amp;quot;&lt;br&gt;
for(j=1; j&amp;lt;=nf; j++) # 连接 new_main_lst&lt;br&gt;
if( j != i ) new_main_lst = new_main_lst &amp;quot; &amp;quot; $j&lt;br&gt;
permutation( new_main_lst, buffer &amp;quot; &amp;quot; $i )&lt;br&gt;
}&lt;br&gt;
}&lt;br&gt;
&#39; $*&lt;br&gt;
执行&lt;br&gt;
$ ./permu&lt;br&gt;
屏幕上出现&lt;br&gt;
请输入排列的元素,各元素间请用空白隔开&lt;/p&gt;
&lt;p&gt;若输入 1 2 3 回车,结果印出&lt;br&gt;
1 2 3&lt;br&gt;
1 3 2&lt;br&gt;
2 1 3&lt;br&gt;
2 3 1&lt;br&gt;
3 1 2&lt;br&gt;
3 2 1&lt;/p&gt;
&lt;p&gt;共 6 种排列方式&lt;/p&gt;
&lt;h4 id=&#34;-说-明--&#34;&gt;[ 说 明 : ]&lt;/h4&gt;
&lt;p&gt;有些较旧版的awk,并不容许使用者指定$0之值. 此时可改用gawk, 或 nawk.否则也可自行使用 split() 函数来分割 main_lst.&lt;br&gt;
为避免执行子函数时破坏 new_main_lst, nf, i, j 故把这些变量也列于参数列上. 如此,new_main_lst, nf, i, j 将被当成局部变量,而不会受到子函数中同名的变量影响. 读者声明函数时,参数列上不妨将这些 &amp;ldquo;虚列的参数&amp;rdquo; 与真正用于传递信息的参数间以较长的空白隔开, 以便于区别.&lt;br&gt;
awk 中欲将字符串concatenation(连接)时, 直接将两字符串并置即可(Implicit Operator).&lt;/p&gt;
&lt;h4 id=&#34;例如--1&#34;&gt;例如 :&lt;/h4&gt;
&lt;p&gt;awk &#39;&lt;br&gt;
BEGIN{&lt;br&gt;
A = &amp;ldquo;This &amp;quot;&lt;br&gt;
B = &amp;ldquo;is a &amp;quot;&lt;br&gt;
C = A B &amp;ldquo;key.&amp;rdquo; # 变量A与B之间应留空白,否则&amp;quot;AB&amp;quot;将代表另一新变量.&lt;br&gt;
print C&lt;br&gt;
} &#39;&lt;br&gt;
结果将印出&lt;br&gt;
This is a key.&lt;br&gt;
awk使用者所编写的函数可再重用, 并不需要每个awk式中都重新编写.&lt;br&gt;
将函数部分单独编写于一文件中, 当需要用到该函数时再以下列方式include进来.&lt;br&gt;
$ awk -f 函数文件名 -f awk主程序文件名 数据文件文件名&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>12.附录</title>
      <link>https://wukong.tongji.edu.cn/internal/zhuqianshu.awk-best-manual/12/</link>
      <pubDate>Mon, 21 Dec 2020 00:00:00 +0000</pubDate>
      <guid>https://wukong.tongji.edu.cn/internal/zhuqianshu.awk-best-manual/12/</guid>
      <description>&lt;h2 id=&#34;附录-a---pattern&#34;&gt;附录 A ──  Pattern&lt;/h2&gt;
&lt;p&gt;awk 通过判断 Pattern 之值来决定是否执行其后所对应的Actions.这里列出几种常见的Pattern :&lt;/p&gt;
&lt;h3 id=&#34;begin&#34;&gt;BEGIN&lt;/h3&gt;
&lt;p&gt;BEGIN 为 awk 的保留字, 是一种特殊的 Pattern.&lt;br&gt;
BEGIN 成立(其值为true)的时机是: &amp;ldquo;awk 程序一开始执行, 尚未读取任何数据之前.&amp;rdquo; 所以在 BEGIN { Actions } 语法中, 其 Actions 部份仅于程序一开始执行时被执行一次. 当 awk 从数据文件读入数据行后, BEGIN 便不再成立, 故不论有多少数据行, 该 Actions 部份仅被执行&lt;br&gt;
一次.&lt;br&gt;
一般常把 &amp;ldquo;与数据文件内容无关&amp;rdquo; 与 &amp;ldquo;只需执行ㄧ次&amp;rdquo; 的部分置于该Actions(以 BEGIN 为 Pattern)中.&lt;br&gt;
例如:&lt;br&gt;
BEGIN {&lt;br&gt;
FS = &amp;ldquo;[ \t:]&amp;rdquo; # 于程序一开始时, 改变awk切割字段的方式&lt;br&gt;
RS = &amp;quot;&amp;quot; # 于程序一开始时, 改变awk分隔数据行的方式&lt;br&gt;
count = 100 # 设定变量 count 的起始值&lt;br&gt;
print &amp;quot; This is a title line &amp;quot; # 印出一行 title&lt;br&gt;
}&lt;br&gt;
&amp;hellip;&amp;hellip;. # 其它 Pattern { Actions } &amp;hellip;..&lt;br&gt;
有些awk程序甚至&amp;quot;不需要读入任何数据行&amp;quot;. 遇到这情况可把整个程序置于以 BEGIN 为 Pattern的 Actions 中.&lt;br&gt;
例如 :&lt;br&gt;
BEGIN { print &amp;quot; Hello ! the Word ! &amp;quot; }&lt;br&gt;
注意 :执行该类仅含 BEGIN { Actions } 的程序时, awk 并不会开启任何数据文件进行处理.&lt;/p&gt;
&lt;h3 id=&#34;end&#34;&gt;END&lt;/h3&gt;
&lt;p&gt;END 为 awk 的保留字, 是另一种特殊的 Pattern.&lt;br&gt;
END 成立(其值为true)的时机与 BEGIN 恰好相反, 为:&amp;ldquo;awk 处理完所有数据, 即将离开程序时&amp;quot;平常读入数据行时, END并不成立, 故其对应的 Actions 并不被执行; 唯有当awk读完所有数据时, 该 Actions 才会被执行&lt;br&gt;
注意 : 不管数据行有多少笔, 该 Actions 仅被执行一次.&lt;/p&gt;
&lt;h3 id=&#34;关系表达式&#34;&gt;关系表达式&lt;/h3&gt;
&lt;p&gt;使用像 &amp;quot; A 关系运算符 B&amp;rdquo; 的表达式当成 Pattern.&lt;br&gt;
当 A 与 B 存在所指定的关系(Relation)时, 该 Pattern 就算成立(true).&lt;br&gt;
例如 :&lt;br&gt;
length($0) &amp;lt;= 80 { print $0 }&lt;br&gt;
上式中 length($0)&amp;lt;= 80 是一个 Pattern, 当 $0(数据行)之长度小于等于80时该 Pattern 之值为true, 将执行其后的 Action (打印该数据行).&lt;/p&gt;
&lt;p&gt;awk 中提供下列 关系运算符(Relation Operator)&lt;br&gt;
运算符 含意&lt;br&gt;
&amp;gt; 大于&lt;br&gt;
&amp;lt; 小于&lt;br&gt;
&amp;gt;= 大于或等于&lt;br&gt;
&amp;lt;= 小于或等于&lt;br&gt;
== 等于&lt;br&gt;
!= 不等于&lt;br&gt;
~ match&lt;br&gt;
!~ not match&lt;br&gt;
上列关系运算符除~(match)与!~(not match)外与 C 语言中之含意一致.&lt;br&gt;
~(match) 与!~(match) 在 awk 之含意简述如下 :&lt;br&gt;
若 A 为一字符串, B 为一正则表达式.&lt;br&gt;
A ~B 判断 字符串A 中是否 包含 能匹配(match)B式样的子字符串.&lt;br&gt;
A !~B 判断 字符串A 中是否 未包含 能匹配(match)B式样的子字符串.&lt;br&gt;
例如 :&lt;br&gt;
$0 ~ /program[0-9]+.c/ { print $0 }&lt;br&gt;
$0 ~ /program[0-9]+.c/ 整个是一个 Pattern, 用来判断$0(数据行)中是否含有可 match /program[0-9]+.c/ 的子字符串, 若$0 中含有该类字符串, 则执行 print (打印该行数据).&lt;br&gt;
Pattern 中被用来比对的字符串为$0 时(如本例), 可仅以正则表达式部分表示整个Pattern.&lt;br&gt;
故本例的 Pattern 部分$0 ~/program[0-9]+.c/ 可仅用/program[0-9]+.c/表之(有关匹配及正则表达式请参考 附录 E )&lt;/p&gt;
&lt;h3 id=&#34;正则表达式&#34;&gt;正则表达式&lt;/h3&gt;
&lt;p&gt;直接使用正则表达式当成 Pattern; 此为 $0 ~ 正则表达式 的简写.&lt;br&gt;
该 Pattern 用以判断 $0(数据行) 中是否含有匹配该正则表达式的子字符串; 若含有该成立(true) 则执行其对应的 Actions.&lt;br&gt;
例如 :&lt;br&gt;
/^[0-9]&lt;em&gt;$/ { print &amp;ldquo;This line is a integer !&amp;rdquo; }&lt;br&gt;
与 $0 ~/^[0-9]&lt;/em&gt;$/ { print &amp;ldquo;This line is a integer !&amp;rdquo; } 相同&lt;/p&gt;
&lt;h3 id=&#34;混合-pattern&#34;&gt;混合 Pattern&lt;/h3&gt;
&lt;p&gt;之前所介绍的各种 Patterns, 其计算后结果为一逻辑值(True or False).awk 中逻辑值彼此间可通过&amp;amp;&amp;amp;(and), ||(or),  !(not) 结合成一个新的逻辑值.故不同 Patterns 彼此可通过上述结合符号来结合成一个新的 Pattern. 如此可进行复杂的条件判断.&lt;br&gt;
例 如 :&lt;br&gt;
FNR &amp;gt;= 23 &amp;amp;&amp;amp; FNR &amp;lt;= 28 { print &amp;quot;     &amp;quot; $0 }&lt;br&gt;
上式利用&amp;amp;&amp;amp; (and) 将两个 Pattern 求值的结果合并成一个逻辑值.&lt;br&gt;
该式将数据文件中 第23行 到 28行 向右移5格(先输出5个空白字符)后输出.&lt;br&gt;
( FNR 为awk的内建变量, 请参考 附录 D )&lt;/p&gt;
&lt;h3 id=&#34;pattern1--pattern2&#34;&gt;Pattern1 , Pattern2&lt;/h3&gt;
&lt;p&gt;遇到这种 Pattern, awk 会帮您设立一个 switch(或flag).&lt;br&gt;
当awk读入的数据行使得 Pattern1 成立时, awk 会打开(turn on)这 switch.&lt;br&gt;
当awk读入的数据行使得 Pattern2 成立时, awk 会关上(turn off)这个 switch.&lt;br&gt;
该 Pattern 成立的条件是 :&lt;br&gt;
当这个 switch 被打开(turn on)时 (包括 Pattern1, 或 Pattern2 成立的情况)&lt;br&gt;
例 如 :&lt;br&gt;
FNR &amp;gt;= 23 &amp;amp;&amp;amp; FNR &amp;lt;= 28 { print &amp;quot;     &amp;quot; $0 }&lt;br&gt;
可改写为&lt;br&gt;
FNR == 23 , FNR == 28 { print &amp;quot;     &amp;quot; $0 }&lt;br&gt;
说 明 :&lt;br&gt;
当 FNR &amp;gt;= 23 时, awk 就 turn on 这个 switch; 因为随着数据行的读入, awk不停的累加 FNR. 当 FNR = 28 时, Pattern2 (FNR == 28) 便成立, 这时 awk 会关上这个 switch.&lt;br&gt;
当 switch 打开的期间, awk 会执行  print &amp;quot;     &amp;quot; $0&lt;br&gt;
( FNR 为awk的内建变量, 请参考 附录 D )&lt;/p&gt;
&lt;h2 id=&#34;附录-b--actions&#34;&gt;附录 B ── Actions&lt;/h2&gt;
&lt;p&gt;Actions 是由下列指令(statement)所组成 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表达式 ( function calls, assignments..)&lt;/li&gt;
&lt;li&gt;print 表达式列表&lt;/li&gt;
&lt;li&gt;printf( 格式化字符串, 表达式列表)&lt;/li&gt;
&lt;li&gt;if( 表达式 ) 语句 [else 语句]&lt;/li&gt;
&lt;li&gt;while( 表达式 ) 语句&lt;/li&gt;
&lt;li&gt;do 语句 while( 表达式)&lt;/li&gt;
&lt;li&gt;for( 表达式; 表达式; 表达式) 语句&lt;/li&gt;
&lt;li&gt;for( variable in array) 语句&lt;/li&gt;
&lt;li&gt;delete&lt;/li&gt;
&lt;li&gt;break&lt;/li&gt;
&lt;li&gt;continue&lt;/li&gt;
&lt;li&gt;next&lt;/li&gt;
&lt;li&gt;exit [表达式]&lt;/li&gt;
&lt;li&gt;语句&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;awk 中大部分指令与 C 语言中的用法一致, 此处仅介绍较为常用或容易混淆的指令的用法.&lt;/p&gt;
&lt;h3 id=&#34;流程控制指令&#34;&gt;流程控制指令&lt;/h3&gt;
&lt;h3 id=&#34;if-指令&#34;&gt;if 指令&lt;/h3&gt;
&lt;p&gt;语法&lt;br&gt;
if (表达式) 语句1 [else 语句2 ]&lt;br&gt;
范例 :&lt;br&gt;
if( $1 &amp;gt; 25 )&lt;br&gt;
print &amp;ldquo;The 1st field is larger than 25&amp;rdquo;&lt;br&gt;
else print &amp;ldquo;The 1st field is not larger than 25&amp;rdquo;&lt;br&gt;
(a)与 C 语言中相同, 若 表达式 计算(evaluate)后之值不为 0 或空字符串, 则执行 语句1; 否则执行 语句2.&lt;br&gt;
(b)进行逻辑判断的表达式所返回的值有两种, 若最后的逻辑值为true, 则返回1, 否则返回0.&lt;br&gt;
(c)语法中else 语句2 以[ ] 前后括住表示该部分可视需要而予加入或省略.&lt;/p&gt;
&lt;h3 id=&#34;while-指令&#34;&gt;while 指令&lt;/h3&gt;
&lt;p&gt;语法 :&lt;br&gt;
while( 表达式 ) 语句&lt;br&gt;
范例 :&lt;br&gt;
while( match(buffer,/[0-9]+.c/ ) ){&lt;br&gt;
print &amp;ldquo;Find :&amp;rdquo; substr( buffer,RSTART, RLENGTH)&lt;br&gt;
buff = substr( buffer, RSTART + RLENGTH)&lt;br&gt;
}&lt;br&gt;
上列范例找出 buffer 中所有能匹配 /[0-9]+.c/(数字之后接上 &amp;ldquo;.c&amp;quot;的所有子字符串).&lt;br&gt;
范例中 while 以函数 match( )所返回的值做为判断条件. 若buffer 中还含有匹配指定条件的子字符串(match成功), 则 match()函数返回1,while 将持续进行其后的语句.&lt;/p&gt;
&lt;h3 id=&#34;do-while-指令&#34;&gt;do-while 指令&lt;/h3&gt;
&lt;p&gt;语法 :&lt;br&gt;
do 语句 while(表达式)&lt;br&gt;
范例 :&lt;br&gt;
do{&lt;br&gt;
print &amp;ldquo;Enter y or n ! &amp;quot;&lt;br&gt;
getline data&lt;br&gt;
} while( data !~ /^[YyNn]$/)&lt;/p&gt;
&lt;p&gt;(a) 上例要求用户从键盘上输入一个字符, 若该字符不是Y, y, N, 或 n则会不停执行该循环, 直到读取正确字符为止.&lt;br&gt;
(b)do-while 指令与 while 指令 最大的差异是 : do-while 指令会先执行statement而后再判断是否应继续执行. 所以, 无论如何其 statement 部分至少会执行一次.&lt;/p&gt;
&lt;h3 id=&#34;for-statement-指令一&#34;&gt;for Statement 指令(一)&lt;/h3&gt;
&lt;p&gt;语法 :&lt;br&gt;
for(variable in  array ) statement&lt;br&gt;
范例 : 执行下列命令&lt;br&gt;
awk &#39;&lt;br&gt;
BEGIN{&lt;br&gt;
X[1]= 50; X[2]= 60; X[&amp;ldquo;last&amp;rdquo;]= 70&lt;br&gt;
for( any in X )&lt;br&gt;
printf(&amp;ldquo;X[%s] = %d\n&amp;rdquo;, any, X[any] )&lt;br&gt;
}&#39;&lt;br&gt;
结果输出 :&lt;br&gt;
X[last] = 70&lt;br&gt;
X[1] = 50&lt;br&gt;
X[2] = 60&lt;br&gt;
(a)这个 for 指令, 专用以查找数组中所有的下标值, 并依次使用所指定的变量予以记录. 以本例而言, 变量 any 将逐次代表 &amp;ldquo;last&amp;rdquo;, 1 及2 .&lt;br&gt;
(b)以这个 for 指令, 所查找出的下标之值彼此间并无任何次续关系.&lt;br&gt;
(c)第5节中有该指令的使用范例, 及解说.&lt;/p&gt;
&lt;h3 id=&#34;for-statement-指令二&#34;&gt;for Statement 指令(二)&lt;/h3&gt;
&lt;p&gt;语法 :&lt;br&gt;
for(expression1; expression2; expression3) statement&lt;br&gt;
范例 :&lt;br&gt;
for(ｉ=1; i&amp;lt; =10; i++)  sum = sum + i&lt;br&gt;
说明 :&lt;br&gt;
(a)上列范例用以计算 1 加到 10 的总和.&lt;br&gt;
(b)expression1  常用于设定该 for 循环的起始条件, 如上例中的 i=1&lt;br&gt;
expression2 用于设定该循环的停止条件, 如上例中的 i &amp;lt;= 10&lt;br&gt;
expression3 常用于改变 counter 之值, 如上例中的 i++&lt;/p&gt;
&lt;h3 id=&#34;break-指令&#34;&gt;break 指令&lt;/h3&gt;
&lt;p&gt;break 指令用以强迫中断(跳离) for, while, do-while 等循环.&lt;br&gt;
范例 :&lt;br&gt;
while(  getline &amp;lt; &amp;ldquo;datafile&amp;rdquo; &amp;gt; 0 )&lt;br&gt;
{&lt;br&gt;
if( $1 == 0 )&lt;br&gt;
break&lt;br&gt;
else&lt;br&gt;
print $2 / $1&lt;br&gt;
}&lt;br&gt;
上例中, awk 不断地从文件 datafile 中读取资料, 当$1等于0时,就停止该执行循环.&lt;/p&gt;
&lt;h3 id=&#34;continue-指令&#34;&gt;continue 指令&lt;/h3&gt;
&lt;p&gt;循环中的 statement 进行到一半时, 执行 continue 指令来略过循环中尚未执行的statement.&lt;br&gt;
范例 :&lt;br&gt;
for( index in X_array)&lt;br&gt;
{&lt;br&gt;
if( index !~ /[0-9]+/ )  continue&lt;br&gt;
print &amp;ldquo;There is a digital index&amp;rdquo;, index&lt;br&gt;
}&lt;br&gt;
上例中若 index 不为数字则执行 continue, 故将略过(不执行)其后的指令.&lt;br&gt;
需留心 continue 与 break 的差异 : 执行 continue 只是掠过其后未执行的statement, 但并未跳离开该循环.&lt;/p&gt;
&lt;h3 id=&#34;next-指令&#34;&gt;next 指令&lt;/h3&gt;
&lt;p&gt;执行 next 指令时, awk 将掠过位于该指令(next)之后的所有指令(包括其后的所有Pattern { Actions }), 接著读取下一笔数据行,继续从第一个 Pattern {Actions} 执行起.&lt;br&gt;
范例 :&lt;br&gt;
/^[ \t]&lt;em&gt;$/  {  print &amp;ldquo;This is a blank line! Do nothing here !&amp;rdquo;&lt;br&gt;
next&lt;br&gt;
}&lt;br&gt;
$2 != 0 { print $1, $1/$2 }&lt;br&gt;
上例中, 当 awk 读入的数据行为空白行时( match /^[ ]&lt;/em&gt;$/ ),除打印消息外只执行 next, 故 awk 将略过其后的指令, 继续读取下一笔资料, 从头(第一个 Pattern { Actions })执行起.&lt;/p&gt;
&lt;h3 id=&#34;exit-指令&#34;&gt;exit 指令&lt;/h3&gt;
&lt;p&gt;执行 exit 指令时, awk将立刻跳离(停止执行)该awk程序.&lt;/p&gt;
&lt;h3 id=&#34;awk-中的-io-指令&#34;&gt;awk 中的 I/O 指令&lt;/h3&gt;
&lt;h3 id=&#34;printf-指令&#34;&gt;printf 指令&lt;/h3&gt;
&lt;p&gt;该指令与 C 语言中的用法相同, 可借由该指令控制资料输出时的格式.&lt;br&gt;
语法 :&lt;br&gt;
printf(&amp;ldquo;format&amp;rdquo;, item1, item2,.. )&lt;br&gt;
范 例 :&lt;br&gt;
id = &amp;ldquo;BE-2647&amp;rdquo;;  ave = 89&lt;br&gt;
printf(&amp;ldquo;ID# : %s   Ave Score : %d\n&amp;rdquo;, id, ave)&lt;br&gt;
(a)结果印出 :&lt;br&gt;
ID# : BE-2647   Ave Score : 89&lt;br&gt;
(b)format 部分是由 一般的字串(String Constant) 及 格式控制字符(Formatcontrol letter, 其前会加上一个%字符)所构成. 以上式为例&amp;quot;ID# : &amp;quot; 及 &amp;quot;  Ave Score : &amp;quot; 为一般字串. %s 及 %d 为格式控制字符.&lt;br&gt;
(c)打印时, 一般字串将被原封不动地打印出来. 遇到格式控制字符时,则依序把 format后方之 item 转换成所指定的格式后进行打印.&lt;br&gt;
(d)有关的细节, 读者可从介绍 C 语言的书籍上得到较完整的介绍.&lt;br&gt;
(e)print 及 printf 两个指令, 其后可使用 &amp;gt; 或 &amp;raquo; 将输出到stdout 的数据重定向到其它文件, 7.1 节中有完整的&lt;/p&gt;
&lt;h3 id=&#34;print-指令&#34;&gt;print 指令&lt;/h3&gt;
&lt;p&gt;范 例 :&lt;br&gt;
id = &amp;ldquo;BE-267&amp;rdquo;;  ave = 89&lt;br&gt;
print &amp;ldquo;ID# :&amp;rdquo;, id, &amp;ldquo;Ave Score :&amp;ldquo;ave&lt;br&gt;
(a)结果印出 :&lt;br&gt;
ID# : BE-267 Ave Score :89&lt;br&gt;
(b)print 之后可接上字串常数(Constant String)或变量. 它们彼此间可用&amp;rdquo;,&amp;rdquo; 隔开.&lt;br&gt;
(c)上式中, 字串 &amp;ldquo;ID# :&amp;rdquo; 与变量 id 之间使用&amp;rdquo;,&amp;ldquo;隔开, 打印时两者之间会以自动 OFS(请参考 附录D 內建变量 OFS) 隔开. OFS 之值一般內定为 &amp;ldquo;一个空格&amp;rdquo;&lt;br&gt;
(d)上式中, 字串 &amp;ldquo;Ave Score :&amp;rdquo; 与变量ave之间并未以&amp;rdquo;,&amp;ldquo;隔开, awk会将这两者先当成字串concate在一起(变成&amp;quot;Ave Score :89&amp;rdquo;)后,再予打印&lt;/p&gt;
&lt;h3 id=&#34;getline-指令&#34;&gt;getline 指令&lt;/h3&gt;
&lt;p&gt;语法&lt;br&gt;
语法由何处读取数据数据读入后置于getline var &amp;lt; file所指定的 file变量 var(var省略时,表示置于$0)getline varpipe 变量变量 var(var省略时,表示置于$0)getline var见 注一变量 var(var省略时,表示置于$0)&lt;br&gt;
getline 一次读取一行资料, 若读取成功则return 1,若读取失败则return -1, 若遇到文件结束(EOF), 则return 0&lt;/p&gt;
&lt;h3 id=&#34;close--指令&#34;&gt;close  指令&lt;/h3&gt;
&lt;p&gt;该指令用以关闭一个打开的文件, 或 pipe (见下例)&lt;br&gt;
范 例 :&lt;br&gt;
BEGIN {  print &amp;ldquo;ID #   Salary&amp;rdquo; &amp;gt; &amp;ldquo;data.rpt&amp;rdquo; } &lt;br&gt;
{  print $1 , $2 * $3  | &amp;ldquo;sort -k 1 &amp;gt; data.rpt&amp;rdquo; }  &lt;br&gt;
END{  close( &amp;ldquo;data.rpt&amp;rdquo; )&lt;br&gt;
close( &amp;ldquo;sort -k 1 &amp;gt; data.rpt&amp;rdquo; )&lt;br&gt;
print &amp;quot; There are&amp;rdquo;, NR, &amp;ldquo;records processed.&amp;rdquo;&lt;br&gt;
}&lt;br&gt;
说 明 :&lt;br&gt;
(a)上例中, 一开始执行 print &amp;ldquo;ID #   Salary&amp;rdquo; &amp;gt; &amp;ldquo;data.rpt&amp;rdquo; 指令来输出一行抬头. 它使用 I/O Redirection ( &amp;gt; )将数据转输出到data.rpt,故此时文件 data.rpt 是处於 Open 状态.&lt;br&gt;
(b)指令 print $1, $2 * $3 不停的将输出的资料送往 pipe(|), awk在程序将结束时才会呼叫 shell 使用指令 &amp;ldquo;sort -k 1 &amp;gt; data.rpt&amp;rdquo; 来处理 pipe 中的数据; 并未立即执行, 这点与 Unix中pipe的用法不尽相同.&lt;br&gt;
(c)最后希望於文件 data.rpt 的末尾处加上一行 &amp;ldquo;There are&amp;hellip;..&amp;quot;.但此时, Shell尚未执行 &amp;ldquo;sort -k 1 &amp;gt; data.rpt&amp;rdquo; 故各数据行排序后的 ID 及 Salary 等数据尚未写入data.rpt. 所以得命令 awk 提前先通知 Shell 执行命令 &amp;ldquo;sort -k 1 &amp;gt; data.rpt&amp;rdquo; 来处理 pipe 中的资料. awk中这个动作称为 close pipe. 是由执行 close ( &amp;ldquo;shell command&amp;rdquo; )来完成. 需留心 close( )指令中的 shell command&lt;br&gt;
需与&amp;rdquo;|&amp;ldquo;后方的 shell command 完全相同(一字不差), 较佳的方法是先以该字串定义一个简短的变量, 程序中再以此变量代替该shell command &lt;br&gt;
(d)为什么执行 close(&amp;ldquo;data.rpt&amp;rdquo;) ?  因为 sort 完后的资料也将写到data.rpt,而该文件正为awk所打开使用(write)中, 故awk程式中应先关闭data.rpt. 以免造成因二个 processes 同时打开一个文件进行输出(write)所产生的错误.&lt;/p&gt;
&lt;h3 id=&#34;system-指令&#34;&gt;system 指令&lt;/h3&gt;
&lt;p&gt;该指令用以执行 Shell上的 command.&lt;br&gt;
范 例 :&lt;br&gt;
DataFile = &amp;ldquo;invent.rpt&amp;rdquo;&lt;br&gt;
system( &amp;ldquo;rm &amp;quot; DataFile )&lt;br&gt;
说明 :&lt;br&gt;
(a)system(&amp;ldquo;字符串&amp;rdquo;)指令接受一个字符串当成Shell的命令. 上例中, 使用一个字串常数&amp;quot;rm &amp;quot; 连接(concate)一个变量 DataFile 形成要求 Shell 执行的命令.Shell 实际执行的命令为 &amp;ldquo;rm invent.rpt&amp;rdquo;.&lt;/p&gt;
&lt;h3 id=&#34;-pipe指令&#34;&gt;&amp;ldquo;|&amp;rdquo; pipe指令&lt;/h3&gt;
&lt;p&gt;&amp;ldquo;|&amp;rdquo; 配合 awk 输出指令, 可把 output 到 stdout 的资料继续转送给Shell 上的某一命令当成input的资料.&lt;br&gt;
&amp;ldquo;|&amp;rdquo;  配合 awk getline 指令, 可呼叫 Shell 执行某一命令, 再以 awk 的 getline 指令将该命令的所产生的资料读进 awk 程序中.&lt;br&gt;
范 例 :&lt;br&gt;
{ print $1, $2 * $3  | &amp;ldquo;sort -k 1 &amp;gt; result&amp;rdquo; }    &lt;br&gt;
&amp;ldquo;date&amp;rdquo; |  getline  Date_data&lt;br&gt;
读者请参考7.2 节,其中有完整的范例说明.&lt;/p&gt;
&lt;h3 id=&#34;awk-释放所占用的记忆体的指令&#34;&gt;awk 释放所占用的记忆体的指令&lt;/h3&gt;
&lt;p&gt;awk 程式中常使用数组(Array)来记忆大量数据, delete 指令便是用来释放数组中的元素所占用的内存空间.&lt;br&gt;
范 例 :&lt;br&gt;
for( any in X_arr )&lt;br&gt;
delete X_arr[any]&lt;br&gt;
读者请留心, delete 指令一次只能释放数组中的一个元素.&lt;/p&gt;
&lt;h3 id=&#34;awk-中的数学运算符arithmetic-operators&#34;&gt;awk 中的数学运算符(Arithmetic Operators)&lt;/h3&gt;
&lt;p&gt;+(加), -(減), *(乘), /(除), %(求余数), ^(指数) 与 C 语言中用法相同&lt;/p&gt;
&lt;h3 id=&#34;awk-中的赋值运算符assignment-operators&#34;&gt;awk 中的赋值运算符(Assignment Operators)&lt;/h3&gt;
&lt;p&gt;=, +=, -=, *= , /=, %=, ^=&lt;br&gt;
x += 5 的意思为 x = x + 5, 其余类推.&lt;/p&gt;
&lt;h3 id=&#34;awk-中的条件运算符conditional--operator&#34;&gt;awk 中的条件运算符(Conditional  Operator)&lt;/h3&gt;
&lt;p&gt;语 法 :&lt;br&gt;
判断条件 ? value1 : value2&lt;br&gt;
若 判断条件 成立(true) 则返回 value1, 否则返回 value2.&lt;/p&gt;
&lt;h3 id=&#34;awk-中的逻辑运算符logical-operators&#34;&gt;awk 中的逻辑运算符(Logical Operators)&lt;/h3&gt;
&lt;p&gt;&amp;amp;&amp;amp;( and ), ||(or), !(not)&lt;br&gt;
Extended Regular Expression 中使用 &amp;ldquo;|&amp;rdquo; 表示 or 请勿混淆.&lt;/p&gt;
&lt;h3 id=&#34;awk-中的关系运算符relational-operators&#34;&gt;awk 中的关系运算符(Relational Operators)&lt;/h3&gt;
&lt;p&gt;&amp;gt;, &amp;gt;=, &amp;lt;, &amp;lt; =, ==, !=, ~, !~&lt;/p&gt;
&lt;h3 id=&#34;awk-中其它的运算符&#34;&gt;awk 中其它的运算符&lt;/h3&gt;
&lt;p&gt;+(正号), -(负号),  ++(Increment Operator), - -(Decrement Operator)&lt;/p&gt;
&lt;h3 id=&#34;awk-中各运算符的运算级&#34;&gt;awk 中各运算符的运算级&lt;/h3&gt;
&lt;p&gt;按优先高低排列:&lt;br&gt;
$       (栏位运算元, 例如 : i=3; $i表示第3栏)&lt;br&gt;
^       (指数运算)&lt;br&gt;
+ ,- ,! (正,负号,及逻辑上的 not)&lt;br&gt;
* ,/ ,% (乘,除,余数)&lt;br&gt;
+ ,-    (加,減)&lt;br&gt;
&amp;gt;, &amp;gt;  =,&amp;lt; , &amp;lt; =, ==, != (关系运算符)&lt;br&gt;
~, !~   (match, not match)&lt;br&gt;
&amp;amp;&amp;amp;      (逻辑上的 and)&lt;br&gt;
||      (逻辑上的 or )&lt;br&gt;
? :     (条件运算符)&lt;br&gt;
= , +=, -=,*=, /=, %=, ^= (赋值运算符)&lt;/p&gt;
&lt;h2 id=&#34;附录c--awk-的內建函数built-in-functions&#34;&gt;附录C ── awk 的內建函数(Built-in Functions)&lt;/h2&gt;
&lt;h3 id=&#34;一-字串函数&#34;&gt;(一). 字串函数&lt;/h3&gt;
&lt;h3 id=&#34;index-原字串-找寻的子字串-&#34;&gt;index( 原字串, 找寻的子字串 ):&lt;/h3&gt;
&lt;p&gt;若原字串中含有欲找寻的子字串,则返回该子字串在原字串中第一次出现的位置,若未曾出现该子字串则返回0.&lt;br&gt;
例如执行 :&lt;br&gt;
$ awk  &amp;lsquo;BEGIN{ print index(&amp;ldquo;8-12-94&amp;rdquo;,&amp;quot;-&amp;quot;) }&amp;rsquo;&lt;br&gt;
结果印出&lt;br&gt;
2&lt;/p&gt;
&lt;h3 id=&#34;length-字串---返回该字串的长度&#34;&gt;length( 字串 ) : 返回该字串的长度.&lt;/h3&gt;
&lt;p&gt;例如执行 :　　&lt;br&gt;
$ awk  &amp;lsquo;BEGIN { print length(&amp;ldquo;John&amp;rdquo;) &amp;lsquo;}&lt;br&gt;
结果印出&lt;br&gt;
4&lt;/p&gt;
&lt;h3 id=&#34;match-原字串-用以找寻比对的正则表达式-&#34;&gt;match( 原字串, 用以找寻比对的正则表达式 ):&lt;/h3&gt;
&lt;p&gt;awk会在原字串中找寻合乎正则表达式的子字串. 若合乎条件的子字串有多个, 则以原字串中最左方的子字串为准.&lt;br&gt;
awk找到该字串后会依此字串为依据进行下列动作:&lt;br&gt;
设定awk內建变量 RSTART, RLENGTH :&lt;br&gt;
RSTART =  合条件的子字串在原字串中的位置.&lt;br&gt;
=  0 ; 若未找到合条件的子字串.&lt;br&gt;
RLENGTH = 合条件的子字串长度.&lt;br&gt;
= -1 ; 若未找到合条件的子字串.&lt;br&gt;
返回 RSTART 之值.&lt;br&gt;
例如执行 :&lt;br&gt;
awk &#39; BEGIN {&lt;br&gt;
match( &amp;ldquo;banana&amp;rdquo;, /(an)+/ )&lt;br&gt;
print RSTART, RLENGTH&lt;br&gt;
} &#39;    　　　&lt;br&gt;
执行结果输出&lt;br&gt;
2 4&lt;/p&gt;
&lt;h3 id=&#34;split-原字串-数组名称-分隔字符-&#34;&gt;split( 原字串, 数组名称, 分隔字符 ):&lt;/h3&gt;
&lt;p&gt;awk将依所指定的分隔字符(field separator)来分隔原字串成一个个的栏位(field),并以指定的数组记录各个被分隔的栏位.&lt;br&gt;
例如 :&lt;br&gt;
ArgLst = &amp;ldquo;5P12p89&amp;rdquo;&lt;br&gt;
split( ArgLst, Arr, /[Pp]/)&lt;br&gt;
执行后 : Arr[1]=5,  Arr[2]=12,  Arr[3]=89&lt;/p&gt;
&lt;h3 id=&#34;sprintf格式字符串-项1-项2-&#34;&gt;sprintf(格式字符串, 项1, 项2, &amp;hellip;)&lt;/h3&gt;
&lt;p&gt;该函数的用法与awk或C的输出函数printf()相同. 所不同的是sprintf()会将要求印出的结果当成一个字串返回. 一般最常使用sprintf()来改变资料格式. 如: x 为一数值资料, 若欲将其变成一个含二位小数的资料,可执行如下指令:&lt;br&gt;
x = 28&lt;br&gt;
x = sprintf(&amp;quot;%.2f&amp;rdquo;,x)&lt;br&gt;
执行后 x = &amp;ldquo;28.00&amp;rdquo;&lt;/p&gt;
&lt;h3 id=&#34;sub-比对用的正则表达式-将替換的新字串-原字串-&#34;&gt;sub( 比对用的正则表达式, 将替換的新字串, 原字串 )&lt;/h3&gt;
&lt;p&gt;sub( )将原字串中第一个(最左边)合乎所指定的正则表达式的子字串改以新字串取代.&lt;br&gt;
第二个参数&amp;quot;将替換的新字串&amp;quot;中可用&amp;rdquo;&amp;amp;&amp;ldquo;来代表&amp;quot;合於条件的子字串&amp;rdquo;&lt;br&gt;
承上例,执行下列指令:&lt;br&gt;
A = &amp;ldquo;a6b12anan212.45an6a&amp;rdquo;&lt;br&gt;
sub( /(an)+[0-9]*/, &amp;ldquo;[&amp;amp;]&amp;rdquo;, A)&lt;br&gt;
print A&lt;br&gt;
结果输出&lt;br&gt;
ab12[anan212].45an6a&lt;br&gt;
sub()不仅可执行替换(replacement)的功用,当第二个参数为空字串(&amp;quot;&amp;quot;)时,sub()所执行的是&amp;quot;去除指定字串&amp;quot;的功用.&lt;br&gt;
通过 sub() 与 match() 的搭配使用,可逐次取出原字串中合乎指定条件的所有子字串.&lt;br&gt;
例如执行下列程式:&lt;br&gt;
awk &#39;&lt;br&gt;
BEGIN {&lt;br&gt;
data = &amp;ldquo;p12-P34 P56-p61&amp;rdquo;&lt;br&gt;
while( match( data ,/[0-9]+/) &amp;gt; 0) {&lt;br&gt;
print substr(data, RSTART, RLENGTH )&lt;br&gt;
sub(/[0-9]+/,&amp;quot;&amp;quot;,data)&lt;br&gt;
}&lt;br&gt;
}&amp;rsquo;&lt;br&gt;
结果输出 :&lt;br&gt;
12&lt;br&gt;
34&lt;br&gt;
56&lt;br&gt;
61&lt;br&gt;
sub( )中第三个参数(原字串)若未指定,则其预设值为$0.&lt;br&gt;
可用 sub( /[9-0]+/,&amp;ldquo;digital&amp;rdquo; ) 表示 sub(/[0-9]+/,&amp;ldquo;digital&amp;rdquo;,$0 )&lt;/p&gt;
&lt;h3 id=&#34;gsub-比对用的正则表达式-将替換的新字串-原字串-&#34;&gt;gsub( 比对用的正则表达式, 将替換的新字串, 原字串 )&lt;/h3&gt;
&lt;p&gt;这个函数与 sub()一样,同样是进行字串取代的函数. 唯一不同点是&lt;br&gt;
gsub()会取代所有合条件的子字串.&lt;br&gt;
gsub()会返回被取代的子字串个数.&lt;/p&gt;
&lt;p&gt;请参考 sub().&lt;/p&gt;
&lt;h3 id=&#34;substr-字串起始位置-长度-&#34;&gt;substr( 字串,起始位置 [,长度] ):&lt;/h3&gt;
&lt;p&gt;返回从起始位置起,指定长度的子字串. 若未指定长度,则返回起始位置到字串末尾的子字串.&lt;br&gt;
执行下例&lt;br&gt;
$ awk &amp;lsquo;BEGIN { print substr(&amp;ldquo;User:Wei-Lin Liu&amp;rdquo;, 6)}&amp;rsquo;&lt;br&gt;
结果印出&lt;br&gt;
Wei-Lin Liu&lt;/p&gt;
&lt;h3 id=&#34;二-数学函数&#34;&gt;(二). 数学函数&lt;/h3&gt;
&lt;h3 id=&#34;intx--返回x的整数部分去掉小数&#34;&gt;int(x) : 返回x的整数部分(去掉小数).&lt;/h3&gt;
&lt;p&gt;例如 :&lt;br&gt;
int(7.8) 将返回 7&lt;br&gt;
int(-7.8) 将返回 -7&lt;/p&gt;
&lt;h3 id=&#34;sqrtx--返回x的平方根&#34;&gt;sqrt(x) : 返回x的平方根.&lt;/h3&gt;
&lt;p&gt;例如 :&lt;br&gt;
sqrt(9) 将返回 3&lt;br&gt;
若 x 为负数,则执行 sqrt(x)时将造成 Run Time Error [译者注: 我这里没有发生错误,返回的是&amp;quot;nan&amp;quot;]&lt;/p&gt;
&lt;h3 id=&#34;expx--将返回e的x次方&#34;&gt;exp(x) : 将返回e的x次方.&lt;/h3&gt;
&lt;p&gt;例如 :&lt;br&gt;
exp(1) 将返回 2.71828&lt;/p&gt;
&lt;h3 id=&#34;logx--将返回x以e为底的对数值&#34;&gt;log(x) : 将返回x以e为底的对数值.&lt;/h3&gt;
&lt;p&gt;例如 :&lt;br&gt;
log(exp(1))  将返回 1&lt;br&gt;
若 x&amp;lt; 0 ,则执行 sqrt(x)时将造成 Run Time Error. [译者注: 我这里也没有发生错误,返回的是&amp;quot;nan&amp;quot;]&lt;/p&gt;
&lt;h3 id=&#34;sinx--x-须以弧度为单位sinx将返回x的sin函数值&#34;&gt;sin(x) : x 须以弧度为单位,sin(x)将返回x的sin函数值.&lt;/h3&gt;
&lt;h3 id=&#34;cosx--x-须以弧度为单位cosx将返回x的cos函数值&#34;&gt;cos(x) : x 须以弧度为单位,cos(x)将返回x的cos函数值&lt;/h3&gt;
&lt;h3 id=&#34;atan2yx--返回-yx-的tan反函数之值返回值系以弧度为单位&#34;&gt;atan2(y,x) : 返回 y/x 的tan反函数之值,返回值系以弧度为单位.&lt;/h3&gt;
&lt;h3 id=&#34;rand--返回介于-0与1之间的近似随机数值-0--rand1&#34;&gt;rand() : 返回介于 0与1之间的(近似)随机数值; 0 &amp;lt; rand()&amp;lt;1.&lt;/h3&gt;
&lt;p&gt;除非使用者自行指定rand()函数起始的种子,否则每次执行awk程式时,  rand()函数都将使用同一个內定的种子,来产生随机数.&lt;/p&gt;
&lt;h3 id=&#34;srandx--指定以x为rand-函数起始的种子&#34;&gt;srand([x]) : 指定以x为rand( )函数起始的种子.&lt;/h3&gt;
&lt;p&gt;若省略了x,则awk会以执行时的日期与时间为rand()函数起始的种子.&lt;/p&gt;
&lt;h2 id=&#34;附录d--awk-的內建变量-built-in-variables&#34;&gt;附录D ── awk 的內建变量 Built-in Variables&lt;/h2&gt;
&lt;p&gt;因內建变量的个数不多, 此处按其相关性分类说明, 并未按其字母顺序排列.&lt;/p&gt;
&lt;h3 id=&#34;argc&#34;&gt;ARGC&lt;/h3&gt;
&lt;p&gt;ARGC表示命令行上除了选项 -F, -v, -f 及其所对应的参数之外的所有参数的个数.若将&amp;quot;awk程式&amp;quot;直接写於命令列上, 则 ARGC 亦不将该&amp;quot;程式部分&amp;quot;列入计算.&lt;/p&gt;
&lt;h3 id=&#34;argv&#34;&gt;ARGV&lt;/h3&gt;
&lt;p&gt;ARGV数组用以记录命令列上的参数.&lt;br&gt;
例 : 执行下列命令&lt;br&gt;
$ awk  -F\t -v a=8 -f prg.awk  file1.dat file2.dat&lt;br&gt;
或&lt;br&gt;
$ awk  -F\t -v a=8 &amp;lsquo;{ print $1 * a }&amp;rsquo; file1.dat file2.dat&lt;br&gt;
执行上列任一程式后&lt;br&gt;
ARGC    =  3&lt;br&gt;
ARGV[0] = &amp;ldquo;awk&amp;rdquo;&lt;br&gt;
ARGV[1] = &amp;ldquo;file1.dat&amp;rdquo;&lt;br&gt;
ARGV[2] = &amp;ldquo;file2.dat&amp;rdquo;&lt;br&gt;
读者请留心 : 当 ARGC = 3 时, 命令列上仅指定了 2 个文件.&lt;br&gt;
注 :&lt;br&gt;
-F\t 表示以 tab 为栏位分隔字符 FS(field seporator).&lt;br&gt;
-v a=8 是用以初始化程序中的变量 a.&lt;/p&gt;
&lt;h3 id=&#34;filename&#34;&gt;FILENAME&lt;/h3&gt;
&lt;p&gt;FILENAME用以表示目前正在处理的文件档名.&lt;/p&gt;
&lt;h3 id=&#34;fs&#34;&gt;FS&lt;/h3&gt;
&lt;p&gt;栏位分隔字符.&lt;/p&gt;
&lt;h3 id=&#34;0&#34;&gt;$0&lt;/h3&gt;
&lt;p&gt;表示目前awk所读入的数据行.&lt;/p&gt;
&lt;h3 id=&#34;12&#34;&gt;$1,$2..&lt;/h3&gt;
&lt;p&gt;分別表示所读入的数据行之第一栏, 第二栏,..&lt;br&gt;
说明:&lt;br&gt;
当awk读入一笔数据行 &amp;ldquo;A123  8:15&amp;rdquo; 时,会先以$0 记录.&lt;br&gt;
故 $0 = &amp;ldquo;A123  8:15&amp;rdquo;&lt;br&gt;
若程序中进一步使用了 $1, $2.. 或 NF 等內建变量时, awk才会自动分割 $0.&lt;br&gt;
以便取得栏位相关的资料. 切割后各个栏位的资料会分別以$1, $2, $3&amp;hellip;予以记录.&lt;br&gt;
awk內定(default)的 栏位分隔字符(FS) 为 空白字符(空格及tab).&lt;br&gt;
以本例而言, 读者若未改变 FS, 则分割后:&lt;br&gt;
第一栏($1)=&amp;ldquo;A123&amp;rdquo;,  第二栏($2)=&amp;ldquo;8:15&amp;rdquo;.&lt;br&gt;
使用者可用正则表达式自行定义 FS. awk每次需要分割数据行时, 会参考目前FS的值.&lt;br&gt;
例如 :&lt;br&gt;
令 FS = &amp;ldquo;[ :]+&amp;rdquo; 表示任何由 空白&amp;quot; &amp;quot; 或 冒号&amp;quot;:&amp;quot; 所组成的字串都可当成分隔字符, 则分割后 : &lt;br&gt;
第一栏($1) = &amp;ldquo;A123&amp;rdquo;, 第二栏($2) = &amp;ldquo;8&amp;rdquo;, 第三栏($3) = &amp;ldquo;15&amp;rdquo;&lt;/p&gt;
&lt;h3 id=&#34;nr&#34;&gt;NR&lt;/h3&gt;
&lt;p&gt;NR 表从 awk 开始执行该程序后所读取的数据行数.&lt;/p&gt;
&lt;h3 id=&#34;fnr&#34;&gt;FNR&lt;/h3&gt;
&lt;p&gt;FNR 与 NR 功用类似. 不同的是awk每打开一个新的文件,FNR 便从 0 重新累计&lt;/p&gt;
&lt;h3 id=&#34;nf&#34;&gt;NF&lt;/h3&gt;
&lt;p&gt;NF表目前的数据行所被切分的栏位数.&lt;br&gt;
awk 每读入一笔资料后, 在程序中可以 NF 来得知该行数据包含的栏位个数.在下一笔资料被读入之前, NF 并不会改变. 但使用者若自行使用$0来记录数据,例如: 使用 getline , 此时 NF将代表新的 $0 上所记载的资料的栏位个数.&lt;/p&gt;
&lt;h3 id=&#34;ofs&#34;&gt;OFS&lt;/h3&gt;
&lt;p&gt;OFS输出时的栏位分隔字符. 预设值 &amp;quot; &amp;ldquo;(一个空白), 详见下面说明.&lt;/p&gt;
&lt;h3 id=&#34;ors&#34;&gt;ORS&lt;/h3&gt;
&lt;p&gt;ORS输出时数据行的分隔字符. 预设值 &amp;ldquo;\n&amp;rdquo;(跳行), 见下面说明.&lt;/p&gt;
&lt;h3 id=&#34;ofmt&#34;&gt;OFMT&lt;/h3&gt;
&lt;p&gt;OFMT数值资料的输出格式. 预设值 &amp;ldquo;%.6g&amp;rdquo;(若须要时最多印出6位小数)&lt;br&gt;
当使用 print 指令一次印出多项资料时,&lt;br&gt;
例如 : print $1, $2&lt;br&gt;
输出时, awk会自动在 $1 与 $2 之间补上一个 OFS 之值&lt;br&gt;
每次使用 print 输出后, awk会自动补上 ORS 之值.&lt;br&gt;
使用 print 输出数值数据时, awk将采用 OFMT 之值为输出格式.&lt;br&gt;
例如 :&lt;br&gt;
$ awk &amp;lsquo;BEGIN { print 2/3,1; OFS=&amp;quot;:&amp;quot;; OFMT=&amp;quot;%.2g&amp;rdquo;; print 2/3,1 }&amp;rsquo;&lt;br&gt;
输出:&lt;br&gt;
0.666667 1&lt;br&gt;
0.67:1&lt;br&gt;
程序中通过改变OFS和OFMT的值, 改变了指令 print 的输出格式.&lt;/p&gt;
&lt;h3 id=&#34;rs&#34;&gt;RS&lt;/h3&gt;
&lt;p&gt;RS( Record Separator) : awk从文件上读取资料时, 将根据 RS 的定义把资料切割成许多Records,而awk一次仅读入一个Record,以进行处理.&lt;br&gt;
RS 的预设值是 &amp;ldquo;\n&amp;rdquo;. 所以一般 awk一次仅读入一行资料.&lt;br&gt;
有时一个Record含括了几行资料(Multi-line Record). 这情況下不能再以&amp;quot;\n&amp;quot;&lt;br&gt;
来分隔相邻的Records, 可改用 空白行 来分隔.&lt;br&gt;
在awk程式中,令 RS = &amp;quot;&amp;quot; 表示以 空白行 来分隔相邻的Records.&lt;/p&gt;
&lt;h3 id=&#34;rstart&#34;&gt;RSTART&lt;/h3&gt;
&lt;p&gt;RSTART与使用字串函数 match( )有关的变量,详见下面说明.&lt;/p&gt;
&lt;h3 id=&#34;rlength&#34;&gt;RLENGTH&lt;/h3&gt;
&lt;p&gt;RLENGTH与使用字串函数match( )有关之变量.&lt;br&gt;
当使用者使用 match(&amp;hellip;) 函数后, awk会将 match(&amp;hellip;) 执行的结果以RSTART,RLENGTH 记录.&lt;br&gt;
请参考 附录 C awk的內建函数 match().&lt;/p&gt;
&lt;h3 id=&#34;subsep&#34;&gt;SUBSEP&lt;/h3&gt;
&lt;p&gt;SUBSEP(Subscript Separator) 数组下标的分隔字符,&lt;br&gt;
预设值为&amp;quot;\034&amp;quot;实际上, awk中的 数组 只接受 字串 当它的下标,如: Arr[&amp;ldquo;John&amp;rdquo;].&lt;br&gt;
但使用者在 awk 中仍可使用 数字 当阵列的下标, 甚至可使用多维的数组(Multi-dimenisional Array) 如: Arr[2,79]&lt;br&gt;
事实上, awk在接受 Arr[2,79] 之前, 就已先把其下标转换成字串&amp;quot;2\03479&amp;quot;, 之后便以Arr[&amp;ldquo;2\03479&amp;rdquo;] 代替 Arr[2,79].&lt;br&gt;
可参考下例 :&lt;br&gt;
awk &amp;lsquo;BEGIN {&lt;br&gt;
Arr[2,79] = 78&lt;br&gt;
print  Arr[2,79]&lt;br&gt;
print  Arr[ 2 , 79 ]&lt;br&gt;
print  Arr[&amp;ldquo;2\03479&amp;rdquo;]&lt;br&gt;
idx = 2 SUBSEP 79&lt;br&gt;
print Arr[idx]&lt;br&gt;
}&lt;br&gt;
&#39; $*&lt;br&gt;
执行结果输出:&lt;br&gt;
78&lt;br&gt;
78&lt;br&gt;
78&lt;br&gt;
78&lt;/p&gt;
&lt;h2 id=&#34;附录e--正则表达式regular-expression-简介&#34;&gt;附录E ── 正则表达式(Regular Expression) 简介&lt;/h2&gt;
&lt;h3 id=&#34;为什么要使用正则表达式&#34;&gt;为什么要使用正则表达式&lt;/h3&gt;
&lt;p&gt;UNIX 中提供了许多 指令 和 tools, 它们具有在文件中 查找(Search)字串或替换(Replace)字串 的功能. 像 grep, vi , sed, awk,&amp;hellip;&lt;br&gt;
不论是查找字串或替换字串, 都得先告诉这些指令所要查找(被替换)的字串为何.若未能预先明确知道所要查找(被替换)的字串为何, 只知该字串存在的范围或特征时,例如 :&lt;br&gt;
(一)找寻 &amp;ldquo;T0.c&amp;rdquo;, &amp;ldquo;T1.c&amp;rdquo;, &amp;ldquo;T2.c&amp;rdquo;&amp;hellip;. &amp;ldquo;T9.c&amp;rdquo; 当中的任一字串.&lt;br&gt;
(二)找寻至少存在一个 &amp;ldquo;A&amp;quot;的任意字串.&lt;br&gt;
这情況下, 如何告知执行查找字串的指令所要查找的字串为何.&lt;br&gt;
例 (一) 中, 要查找任一在 &amp;ldquo;T&amp;rdquo; 与 &amp;ldquo;.c&amp;rdquo; 之间存在一个阿拉伯数字的字串;当然您可以列举的方式, 一一把所要找寻的字串告诉执行命令的指令.但例 (二) 中合乎该条件的字串有无限种可能,势必无法一一列举.此时,便需要另一种字串表示的方法(协定).&lt;/p&gt;
&lt;h3 id=&#34;什么是正则表达式&#34;&gt;什么是正则表达式&lt;/h3&gt;
&lt;p&gt;正则表达式(以下简称 Regexp)是一种字串表达的方式. 可用以指定具有某特征的所有字串.&lt;br&gt;
注: 为区別于一般字串, 本附录中代表 Regexp 的字串之前皆加 &amp;ldquo;Regexp&amp;rdquo;. awk 程式中常以/&amp;hellip;./括住 Regexp; 以区別于一般字串.&lt;/p&gt;
&lt;h3 id=&#34;组成正则表达式的元素&#34;&gt;组成正则表达式的元素&lt;/h3&gt;
&lt;p&gt;普通字符 除了 . * [ ] + ? ( ) \  ^ $ 外之所有字符.&lt;br&gt;
由普通字符所组成的Regexp其意义与原字串字面意义相同.&lt;br&gt;
例如: Regexp &amp;ldquo;the&amp;rdquo; 与一般字串的 &amp;ldquo;the&amp;rdquo; 代表相同的意义.&lt;br&gt;
. (Meta character) : 用以代表任意一字符.&lt;br&gt;
须留心 UNIX Shell 中使用 &amp;ldquo;&lt;em&gt;&amp;ldquo;表示 Wild card, 可用以代表任意长度的字串.而 Regexp 中使用 &amp;ldquo;.&amp;rdquo; 来代表一个任意字符.(注意: 并非任意长度的字串)Regexp 中 &amp;ldquo;&lt;/em&gt;&amp;rdquo; 另有其它涵意, 并不代表任意长度的字串.&lt;br&gt;
^ 表示该字串必须出现于行首. &lt;br&gt;
$ 表示该字串必须出现于行末.&lt;br&gt;
例如 :&lt;br&gt;
Regexp /^The/ 用以表示所有出现于行首的字串 &amp;ldquo;The&amp;rdquo;.&lt;br&gt;
Regexp /The$/ 用以表示所有出现于行末字串 &amp;ldquo;The&amp;rdquo;.&lt;br&gt;
\ 将特殊字符还原成字面意义的字符(Escape character)&lt;br&gt;
Regexp 中特殊字符将被解释成特定的意义. 若要表示特殊字符的字面(literal meaning)意义时,在特殊字符之前加上&amp;rdquo;&amp;quot;即可.&lt;br&gt;
例如 :&lt;br&gt;
使用Regexp来表示字串 &amp;ldquo;a.out&amp;quot;时, 不可写成 /a.out/.&lt;br&gt;
因为 &amp;ldquo;.&amp;ldquo;是特殊字符, 表任一字符. 可符合 Regexp / a.out/ 的字串将不只 &amp;ldquo;a.out&amp;rdquo; 一个; 字串 &amp;ldquo;a2out&amp;rdquo;, &amp;ldquo;a3out&amp;rdquo;, &amp;ldquo;aaout&amp;rdquo; &amp;hellip;都符合 Regexp /a.out/  正确的用法为:  / a.out/&lt;br&gt;
[&amp;hellip;]字符集合, 用以表示两中括号间所有的字符当中的任一个.&lt;br&gt;
例如:&lt;br&gt;
Regexp /[Tt]/ 可用以表示字符 &amp;ldquo;T&amp;rdquo; 或 &amp;ldquo;t&amp;rdquo;.故 Regexp /[Tt]he/ 表示 字串 &amp;ldquo;The&amp;rdquo; 或 &amp;ldquo;the&amp;rdquo;.&lt;br&gt;
字符集合 [&amp;hellip;] 內不可随意留空白.&lt;br&gt;
例如: Regexp /[ Tt ]/ 其中括号內有空白字符, 除表示&amp;quot;T&amp;rdquo;, &amp;ldquo;t&amp;rdquo; 中任一个字符, 也可代表一个 &amp;quot; &amp;ldquo;(空白字符)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字符集合中可使用 &amp;ldquo;-&amp;rdquo; 来指定字符的区间, 其用法如下:&lt;br&gt;
Regexp /[0-9]/ 等于 /[0123456789]/ 用以表示任意一个阿拉伯数字.&lt;br&gt;
同理 Regexp /[A-Z]/ 用以表示任意一个大写英文字母.&lt;br&gt;
但应留心:&lt;br&gt;
Regexp /[0-9a-z]/ 并不等于 /[0-9][a-z]/; 前者表示一个字符,后者表示二个字符.&lt;br&gt;
Regexp /[-9]/ 或 /[9-]/ 只代表字符 &amp;ldquo;9&amp;quot;或 &amp;ldquo;-&amp;rdquo;.&lt;br&gt;
[^&amp;hellip;]使用[^..] 产生字符集合的补集(complement set).&lt;br&gt;
其用法如下 :&lt;br&gt;
例如: 要指定 &amp;ldquo;T&amp;rdquo; 或 &amp;ldquo;t&amp;rdquo; 之外的任一个字符, 可用 /[^Tt]/ 表之.&lt;br&gt;
同理 Regexp /[^a-zA-Z]/ 表示英文字母之外的任一个字符.&lt;br&gt;
须留心 &amp;ldquo;^&amp;rdquo; 的位置 : &amp;ldquo;^&amp;ldquo;必须紧接於&amp;rdquo;[&amp;ldquo;之后, 才代表字符集合的补集&lt;br&gt;
例如 :Regexp /[0-9^]/ 只是用以表示一个阿拉伯数字或字符&amp;rdquo;^&amp;rdquo;.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;形容字符重复次数的特殊字符.&lt;br&gt;
&amp;ldquo;&lt;em&gt;&amp;rdquo; 形容它前方之字符可出现 1 次或多次, 或不出现(0次).&lt;br&gt;
例如:&lt;br&gt;
Regexp /T[0-9]&lt;/em&gt;.c/ 中 * 形容其前 [0-9] (一个阿拉伯数字)出现的次数可为 0次或 多次.故Regexp /T[0-9]*.c/ 可用以表示&amp;quot;T.c&amp;rdquo;, &amp;ldquo;T0.c&amp;rdquo;, &amp;ldquo;T1.c&amp;rdquo;&amp;hellip;&amp;ldquo;T19.c&amp;rdquo;&lt;br&gt;
+形容其前的字符出现一次或一次以上.&lt;br&gt;
例如:&lt;br&gt;
Regexp /[0-9]+/ 用以表示一位或一位以上的数字.&lt;br&gt;
?  形容其前的字符可出现一次或不出现.&lt;br&gt;
例如:&lt;br&gt;
Regexp /[+-]?[0-9]+/ 表示数字(一位以上)之前可出现正负号或不出现正负号.&lt;br&gt;
(&amp;hellip;)用以括住一群字符,且将之视成一个group(见下面说明)&lt;br&gt;
例如 :&lt;br&gt;
Regexp /12+/   表示字串 &amp;ldquo;12&amp;rdquo;, &amp;ldquo;122&amp;rdquo;, &amp;ldquo;1222&amp;rdquo;, &amp;ldquo;12222&amp;rdquo;,&amp;hellip;&lt;br&gt;
Regexp /(12)+/ 表示字串 &amp;ldquo;12&amp;rdquo;, &amp;ldquo;1212&amp;rdquo;, &amp;ldquo;121212&amp;rdquo;, &amp;ldquo;12121212&amp;rdquo;&amp;hellip;.&lt;br&gt;
上式中 12 以( )括住, 故 &amp;ldquo;+&amp;rdquo; 所形容的是 12, 重复出现的也是 12.&lt;br&gt;
| 表示逻辑上的&amp;quot;或&amp;rdquo;(or)&lt;br&gt;
例如:&lt;br&gt;
Regexp / Oranges? | apples?  | water/ 可用以表示 :  字串 &amp;ldquo;Orange&amp;rdquo;, &amp;ldquo;Oranges&amp;rdquo; 或 &amp;ldquo;apple&amp;rdquo;, &amp;ldquo;apples&amp;rdquo;  或 &amp;ldquo;water&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;match是什么&#34;&gt;match是什么?&lt;/h3&gt;
&lt;p&gt;讨论 Regexp 时, 经常遇到 &amp;ldquo;某字串匹配( match )某 Regexp&amp;quot;的字眼. 其意思为 :  &amp;ldquo;这个 Regexp 可被解释成该字串&amp;rdquo;.&lt;br&gt;
[ 例如] :&lt;br&gt;
字串 &amp;ldquo;the&amp;rdquo; 匹配(match) Regexp /[Tt]he/.&lt;br&gt;
因为 Regexp /[Tt]he/ 可解释成字串 &amp;ldquo;the&amp;rdquo; 或 &amp;ldquo;The&amp;rdquo;, 故字串 &amp;ldquo;the&amp;rdquo; 或 &amp;ldquo;The&amp;quot;都匹配(match) Regexp /[Th]he/.&lt;/p&gt;
&lt;h3 id=&#34;awk-中提供二个关系运算符relational-operator见注一----&#34;&gt;awk 中提供二个关系运算符(Relational Operator,见注一) ~   !~,&lt;/h3&gt;
&lt;p&gt;它们也称之为 match, not match.但函义与一般常称的 match 略有不同.&lt;br&gt;
其定义如下:&lt;br&gt;
A  表一字串, B 表一 Regular Expression&lt;br&gt;
只要 A 字串中存在有子字串可 match( 一般定义的 match) Regexp  B , 则 A ~B 就算成立, 其值为 true, 反之则为 false.&lt;br&gt;
! ~ 的定义与~恰好相反.&lt;br&gt;
例 如 :&lt;br&gt;
&amp;ldquo;another&amp;rdquo; 中含有子字串 &amp;ldquo;the&amp;rdquo; 可 match Regexp /[Tt]he/ , 所以&lt;br&gt;
&amp;ldquo;another&amp;rdquo; ~ /[Tt]he/  之值为 true.&lt;br&gt;
[注 一] : 有些论著不把这两个运算符( ~, !~)与 Relational Operators 归为一类.&lt;/p&gt;
&lt;h3 id=&#34;应用-regular-expression-解题的简例&#34;&gt;应用 Regular Expression 解题的简例&lt;/h3&gt;
&lt;p&gt;下面列出一些应用 Regular Expression 的简例, 部分范例中会更改$0 之值, 若您使用的 awk不允许用户更改 $0时, 请改用 gawk. &lt;br&gt;
例1:&lt;br&gt;
将文件中所有的字串 &amp;ldquo;Regular Expression&amp;rdquo; 或 &amp;ldquo;Regular expression&amp;rdquo; 换成 &amp;ldquo;Regexp&amp;rdquo;&lt;br&gt;
awk &#39;&lt;br&gt;
{ gsub( /Regular[ \t]+[Ee]xpression/, &amp;ldquo;Regexp&amp;rdquo;)&lt;br&gt;
print&lt;br&gt;
}&lt;br&gt;
&#39; $*&lt;br&gt;
例2:&lt;br&gt;
去除文件中的空白行(或仅含空白字符或tab的行)&lt;br&gt;
awk &amp;lsquo;$0 !~ /^[ \t]&lt;em&gt;$/ { print }&amp;rsquo; $&lt;/em&gt;&lt;br&gt;
例3:&lt;br&gt;
在文件中具有 ddd-dddd (电话号码型态, d 表digital)的字串前加上&amp;quot;TEL : &amp;quot;&lt;br&gt;
awk &#39;&lt;br&gt;
{ gsub( /[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]/, &amp;ldquo;TEL : &amp;amp;&amp;rdquo; )&lt;br&gt;
print&lt;br&gt;
}&lt;br&gt;
&#39; $*&lt;br&gt;
例4:&lt;br&gt;
从文件的 Fullname 中分离出 路径 与 档名&lt;br&gt;
awk &#39;&lt;br&gt;
BEGIN{&lt;br&gt;
Fullname = &amp;ldquo;/usr/local/bin/xdvi&amp;rdquo;&lt;br&gt;
match( Fullname, /.&lt;em&gt;//)&lt;br&gt;
path = substr(Fullname, 1, RLENGTH-1)&lt;br&gt;
name = substr(Fullname, RLENGTH+1)&lt;br&gt;
print &amp;ldquo;path :&amp;rdquo;, path,&amp;rdquo;  name :&amp;quot;,name&lt;br&gt;
}&lt;br&gt;
&#39; $&lt;/em&gt;&lt;br&gt;
结果印出&lt;br&gt;
path : /usr/local/bin   name : xdvi&lt;br&gt;
例5:&lt;br&gt;
将某一数值改以现金表示法表示(整数部分每三位加一撇,且含二位小数)&lt;br&gt;
awk &#39;&lt;br&gt;
BEGIN {&lt;br&gt;
Number = 123456789&lt;br&gt;
Number = sprintf(&amp;quot;$%.2f&amp;rdquo;,Number)&lt;br&gt;
while( match(Number,/[0-9][0-9][0-9][0-9]/ ) )&lt;br&gt;
sub(/[0-9][0-9][0-9][.,]/, &amp;ldquo;,&amp;amp;&amp;rdquo;, Number)&lt;br&gt;
print Number&lt;br&gt;
}&lt;br&gt;
&#39; $*&lt;br&gt;
结果输出&lt;br&gt;
$123,456,789.00&lt;br&gt;
例6:&lt;br&gt;
把文件中所有具 &amp;ldquo;program数字.f&amp;quot;形态的字串改为&amp;rdquo;[Ref : program数字.c]&amp;rdquo;&lt;br&gt;
awk &#39;&lt;br&gt;
{&lt;br&gt;
while( match( $0, /program[0-9]+.f/ )  ){&lt;br&gt;
Replace = &amp;ldquo;[Ref : &amp;quot; substr( $0, RSTART, RLENGTH-2) &amp;ldquo;.c]&amp;rdquo;&lt;br&gt;
sub( /program[0-9]+.f/, Replace)&lt;br&gt;
}&lt;br&gt;
print&lt;br&gt;
}&lt;br&gt;
&#39; $*&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
